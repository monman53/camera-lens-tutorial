<meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-E9ZG1KHTVT"></script>
<script src='/scripts/google.js'></script>

<title>Camera Lens Tutorial</title>

<div id="app">
    <canvas id="canvas" @mousedown="mouseDown" @mousemove="mouseMove" @mouseup="mouseUp"></canvas>
    <canvas id="canvas-sensor" @mousedown="mouseDown" @mousemove="mouseMove" @mouseup="mouseUp"
        style="margin-left: 1em;"></canvas>
    <div>
        <label>
            Aperture
            <input type="range" min="0" :max="1" step="0.01" v-model.number="aperture">
            {{aperture}}
        </label>
        <br>
        <label>
            Sensor size
            <input type="range" min="0.1" :max="3" step="0.1" v-model.number="sensor.size">
            {{sensor.size}}
        </label>
        <br>
        <label>
            Sensor position
            <input type="range" :min="focalLength*0.99" max="8" step="0.01" v-model.number="sensor.x">
            {{sensor.x}}
        </label>
        <br>
        <label>
            Lens position
            <input type="range" min="-1" max="1" step="0.0001" v-model.number="lens.x">
            {{lens.x}}
        </label>
        <br>
        <label>
            Lens thickness
            <input type="range" min="0.1" :max="Math.min(5, lens.r*2)" step="0.1" v-model.number="lens.d">
            {{lens.d}}
        </label>
        <br>
        <label>
            Lens R
            <input type="range" :min="lens.d/2" max="100" step="0.1" v-model.number="lens.r">
            {{lens.r}}
        </label>
        <br>
        <label>
            Number of rays
            <input type="range" min="1" max="4096" step="1" v-model.number="rayN">
            {{rayN}}
        </label>
        <br>
        <label>
            Ray width
            <input type="range" min="0.01" max="1.0" step="0.01" v-model.number="rayWidth">
            {{rayWidth}}
        </label>
        <br>
        <label>
            Canvas scale
            <input type="range" min="0.1" max="100" step="0.1" v-model.number="scale">
            {{scale}}
        </label>
        <br>
        <label v-for="light in lights">
            <input type="checkbox" v-model="light.enabled">
            Show light {{light.color}}
            <br>
        </label>
    </div>
    <div>
        <details>
            <summary>Debug</summary>
            moving: {{moving}}
            FPS: {{fps}}<br>
        </details>
    </div>

    <h1>Description</h1>
</div>

<script type="module">
    import { createApp } from 'https://unpkg.com/vue@3/dist/vue.esm-browser.js'
    // import { createApp } from 'https://unpkg.com/vue@3/dist/vue.esm-browser.prod.js'

    createApp({
        data() {
            return {
                canvas: undefined,
                cx: 0,
                cy: 0,
                scale: 50,
                rayN: 512,
                rayWidth: 0.3,
                lens: {
                    x: 0.0,
                    r: 10.0,
                    d: 0.3,
                    n: 1.5,
                },
                sensor: {
                    x: 4.0,
                    size: 1.0,
                },
                aperture: 1.0,
                lights: [
                    { x: -8, y: -3, r: 0.1, color: "rgba(255, 0, 0, 0.8)", enabled: false },
                    { x: -12, y: -3, r: 0.1, color: "rgba(0, 255, 0, 0.8)", enabled: true },
                    { x: -16, y: -3, r: 0.1, color: "rgba(0, 0, 255, 0.8)", enabled: false },
                ],
                moving: -1,
                fps: 0,
            }
        },
        methods: {
            mouseDown(e) {
                const rect = this.canvas.getBoundingClientRect()
                const x = (e.clientX - rect.left - this.cx) / this.scale;
                const y = (e.clientY - rect.top - this.cy) / this.scale;

                this.lights.forEach((light, idx) => {
                    if (Math.pow(x - light.x, 2) + Math.pow(y - light.y, 2) < Math.pow(light.r * 2, 2)) {
                        this.moving = idx;
                    }
                });
            },
            mouseMove(e) {
                if (this.moving >= 0) {
                    const rect = this.canvas.getBoundingClientRect()
                    const x = (e.clientX - rect.left - this.cx) / this.scale;
                    const y = (e.clientY - rect.top - this.cy) / this.scale;
                    this.lights[this.moving].x = Math.min(x, -this.focalLength * 1.001);
                    this.lights[this.moving].y = y;
                }
            },
            mouseUp(e) {
                this.moving = -1;
            },
        },
        computed: {
            focalLength() {
                return this.lens.r / 2 * (this.lens.n - 1);
            },
            lensSize() {
                const theta = Math.acos((this.lens.r - this.lens.d / 2) / this.lens.r);
                return this.lens.r * Math.sin(theta);
            },
            boxWidth() {
                return this.sensor.x - this.lens.x + 0.3;
            },
        },
        mounted() {
            //================================
            // Support functions
            //================================
            const getIntersectionX = (px, py, theta, minX, maxX, y, maxR) => {
                const sin = Math.sin(theta);
                const cos = Math.cos(theta);
                const r = (y - py) / sin;
                const x = px + r * cos;
                if (r >= 0 && minX <= x && x <= maxX) {
                    return [true, x, y, r];
                } else {
                    return [false, px + maxR * cos, py + maxR * sin, maxR];
                }
            }

            const getIntersectionY = (px, py, theta, x, minY, maxY, maxR) => {
                const sin = Math.sin(theta);
                const cos = Math.cos(theta);
                const r = (x - px) / Math.cos(theta);
                const y = py + r * Math.sin(theta);
                if (r >= 0 && minY <= y && y <= maxY) {
                    return [true, x, y, r];
                } else {
                    return [false, px + maxR * cos, py + maxR * sin, maxR];
                }
            }

            const getIntersectionBox = (cx, cy, theta, maxR, skipBehindSensor, immediate) => {
                // Top
                const [hit1, x1, y1, r1] = getIntersectionX(cx, cy, theta, this.lens.x, this.lens.x + this.boxWidth, -this.lensSize, maxR);
                if (hit1 && immediate) {
                    return [hit1, x1, y1, r1];
                }
                // Bottom
                const [hit2, x2, y2, r2] = getIntersectionX(cx, cy, theta, this.lens.x, this.lens.x + this.boxWidth, this.lensSize, maxR);
                if (hit2 && immediate) {
                    return [hit2, x2, y2, r2];
                }

                if (skipBehindSensor) {
                    if (r1 < r2) {
                        return [hit1, x1, y1];
                    } else {
                        return [hit2, x2, y2];
                    }
                }

                // Behind the sensor
                const [hit3, x3, y3, r3] = getIntersectionY(cx, cy, theta, this.lens.x + this.boxWidth, -this.lensSize, this.lensSize, maxR);
                if (hit3 && immediate) {
                    return [hit3, x3, y3, r3];
                }

                // Return closest intersection
                if (r1 <= r2 && r1 <= r3) {
                    return [hit1, x1, y1];
                } else if ((r2 <= r1 && r2 <= r3)) {
                    return [hit2, x2, y2];
                } else {
                    return [hit3, x3, y3];
                }
            }

            //================================
            // Canvas setup
            //================================
            const height = 800;

            // Main canvas
            this.canvas = document.getElementById("canvas");
            this.canvas.height = height;
            this.canvas.width = height * 2;
            const offscreen = new OffscreenCanvas(canvas.width, canvas.height);
            const ctx = offscreen.getContext("2d", { alpha: false });
            const mainCtx = this.canvas.getContext("bitmaprenderer");

            const w = this.canvas.width;
            const h = this.canvas.height;
            this.cx = this.canvas.width * 2 / 3;
            this.cy = this.canvas.height / 2;

            // Sensor canvas
            const sensorCanvas = document.getElementById("canvas-sensor");
            sensorCanvas.height = height;
            sensorCanvas.width = height / 8;
            const sensorCanvasCtx = sensorCanvas.getContext("2d");

            //================================
            // Render callback function
            //================================
            let frames = 0;
            let startTime = new Date().getTime();
            const render = () => {
                // Calculate FPS
                frames += 1;
                let endTime = new Date().getTime();
                if (endTime - startTime >= 1000) {
                    this.fps = frames / (endTime - startTime) * 1000;
                    startTime = endTime;
                    frames = 0;
                }

                //================================
                // Main canvas drawing
                //================================
                const maxR = (w + h) / this.scale; // Long enough

                //--------------------------------
                // Clear canvas
                //--------------------------------
                ctx.reset();
                ctx.fillRect(0, 0, w, h); // background
                ctx.transform(this.scale, 0, 0, this.scale, this.cx, this.cy);
                ctx.globalCompositeOperation = 'lighten';

                //--------------------------------
                // Axes
                //--------------------------------
                ctx.strokeStyle = "white";
                ctx.lineWidth = 0.2 / this.scale;
                // x-axis
                ctx.beginPath();
                ctx.moveTo(-w, 0);
                ctx.lineTo(w, 0);
                ctx.stroke();

                // y-axis
                ctx.beginPath();
                ctx.moveTo(0, -h);
                ctx.lineTo(0, h);
                ctx.stroke();

                //--------------------------------
                // Lights
                //--------------------------------
                let sensorIntersections = new Array(this.lights.length).fill([]);
                // Rays
                this.lights.forEach((light, idx) => {
                    if (!light.enabled) {
                        return;
                    }

                    const x = light.x;
                    const y = light.y;
                    const color = light.color;
                    ctx.strokeStyle = color;

                    let sensorIntersectionsForLight = [];
                    ctx.lineWidth = this.rayWidth / this.scale;
                    for (let i = 0; i < this.rayN; i++) {
                        // Draw outer ray
                        const theta = 2 * Math.PI * i / this.rayN;

                        // Pruning intersection check of left oriented rays for optimization
                        if (Math.PI / 2 <= theta && theta <= Math.PI * 3 / 2) {
                            // Draw light source to infinity ray
                            ctx.beginPath();
                            ctx.moveTo(x, y);
                            ctx.lineTo(x + maxR * Math.cos(theta), y + maxR * Math.sin(theta));
                            ctx.stroke();
                            continue;
                        }

                        // Check intersection with lens
                        const [hitLens, tx, ty] = getIntersectionY(x, y, theta, this.lens.x, -this.lensSize, this.lensSize, maxR);

                        if (!hitLens) {
                            // Draw light to box ray
                            const [hitBox, tx, ty] = getIntersectionBox(x, y, theta, maxR, true);
                            ctx.beginPath();
                            ctx.moveTo(x, y);
                            ctx.lineTo(tx, ty);
                            ctx.stroke();
                            continue;
                        }

                        // Draw light to lens ray
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(tx, ty);
                        ctx.stroke();

                        // Draw inner ray
                        const notHitAperture = -this.lensSize * this.aperture < ty && ty < this.lensSize * this.aperture;
                        if (notHitAperture) {
                            // Calculate refraction direction (phi)
                            const s1 = this.lens.x - light.x;
                            const s2 = this.focalLength * s1 / (s1 - this.focalLength);
                            const ux = s2;
                            const uy = -light.y * (s2 / s1)
                            const phi = Math.atan2(uy - ty, ux);

                            // Check intersection to the sensor
                            const [hitSensor, vx, vy] = getIntersectionY(tx, ty, phi, this.sensor.x, -this.sensor.size, this.sensor.size, maxR, false);

                            // Draw lens to sensor ray
                            if (hitSensor) {
                                ctx.beginPath();
                                ctx.moveTo(tx, ty);
                                ctx.lineTo(vx, vy);
                                ctx.stroke();
                            } else {
                                const [hitBox, vx, vy] = getIntersectionBox(tx, ty, phi, maxR);
                                console.assert(hitBox); // Inner rays should always hit to the box
                                ctx.beginPath();
                                ctx.moveTo(tx, ty);
                                ctx.lineTo(vx, vy);
                                ctx.stroke();
                            }

                            // Record intersection
                            if (hitSensor) {
                                sensorIntersectionsForLight.push(vy);
                                continue;
                            }
                        }
                    }
                    sensorIntersections[idx] = sensorIntersectionsForLight;
                });

                // Source points
                ctx.globalCompositeOperation = 'normal';
                this.lights.forEach((light) => {
                    if (!light.enabled) {
                        return;
                    }

                    {
                        const x = light.x;
                        const y = light.y;
                        const r = light.r;
                        ctx.beginPath();
                        ctx.arc(x, y, r, 0, Math.PI * 2);
                        ctx.lineWidth = 1 / this.scale;
                        ctx.strokeStyle = "black";
                        ctx.stroke();
                    }
                });

                //--------------------------------
                // Camera components
                //--------------------------------
                ctx.lineWidth = 1 / this.scale;
                ctx.strokeStyle = "white";
                ctx.fillStyle = "white";

                //--------------------------------
                // Camera box
                //--------------------------------
                // Upper
                ctx.beginPath();
                ctx.moveTo(this.lens.x, -this.lensSize)
                ctx.lineTo(this.lens.x + this.boxWidth, -this.lensSize);
                ctx.stroke();

                // Bottom
                ctx.beginPath();
                ctx.moveTo(this.lens.x, this.lensSize)
                ctx.lineTo(this.lens.x + this.boxWidth, this.lensSize);
                ctx.stroke();

                // Behind the sensor
                ctx.beginPath();
                ctx.moveTo(this.lens.x + this.boxWidth, -this.lensSize)
                ctx.lineTo(this.lens.x + this.boxWidth, this.lensSize);
                ctx.stroke();

                //--------------------------------
                // Lens
                //--------------------------------
                {
                    const r = this.lens.r;
                    const d = this.lens.d;
                    const theta = Math.acos((r - d / 2) / r);
                    const y = 0;
                    // Left
                    {
                        const x = this.lens.x + (r - d / 2);
                        const startAngle = Math.PI - theta;
                        const endAngle = Math.PI + theta;
                        ctx.beginPath();
                        ctx.arc(x, y, r, startAngle, endAngle);
                        ctx.stroke();
                    }
                    // Right
                    {
                        const x = this.lens.x - (r - d / 2);
                        const startAngle = - theta;
                        const endAngle = theta;
                        ctx.beginPath();
                        ctx.arc(x, y, r, startAngle, endAngle);
                        ctx.stroke();
                    }
                }

                //--------------------------------
                // Focal point
                //--------------------------------
                {
                    const r = 3 / this.scale;
                    const y = 0;
                    // Left
                    {
                        const x = this.lens.x + -this.focalLength;
                        ctx.beginPath();
                        ctx.arc(x, y, r, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                    }
                    // Right
                    {
                        const x = this.lens.x + this.focalLength;
                        ctx.beginPath();
                        ctx.arc(x, y, r, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                    }
                }

                //--------------------------------
                // Aperture
                //--------------------------------
                // upper
                {
                    ctx.beginPath();
                    ctx.moveTo(this.lens.x, -this.lensSize);
                    ctx.lineTo(this.lens.x, -this.lensSize * this.aperture);
                    ctx.stroke();
                }
                // lower
                {
                    ctx.beginPath();
                    ctx.moveTo(this.lens.x, this.lensSize);
                    ctx.lineTo(this.lens.x, this.lensSize * this.aperture);
                    ctx.stroke();
                }

                //--------------------------------
                // Sensor
                //--------------------------------
                ctx.beginPath();
                ctx.moveTo(this.sensor.x, this.sensor.size)
                ctx.lineTo(this.sensor.x, -this.sensor.size);
                ctx.stroke();

                //--------------------------------
                // Copy offscreen render result to main canvas
                //--------------------------------
                mainCtx.transferFromImageBitmap(offscreen.transferToImageBitmap());

                //================================
                // Sensor canvas drawing
                //================================
                sensorCanvasCtx.reset();
                sensorCanvasCtx.fillRect(0, 0, h / 4, h); // background
                const sensorCanvasScale = sensorCanvas.height / (this.sensor.size * 2);
                sensorCanvasCtx.transform(8192, 0, 0, sensorCanvasScale, sensorCanvas.width / 2, sensorCanvas.height / 2);
                sensorCanvasCtx.globalCompositeOperation = 'lighten';

                sensorIntersections.forEach((sensorIntersectionsForLight, idx) => {
                    const color = this.lights[idx].color;
                    sensorCanvasCtx.fillStyle = color;
                    sensorIntersectionsForLight.forEach((y) => {
                        sensorCanvasCtx.beginPath();
                        sensorCanvasCtx.arc(0, y, this.rayWidth / 2 / 50, 0, Math.PI * 2);
                        sensorCanvasCtx.fill();
                    });
                });
            }

            // Render only when data changes
            this.$watch('$data', () => {
                requestAnimationFrame(render);
            }, { deep: true, immediate: true });
        },
    }).mount('#app')
</script>