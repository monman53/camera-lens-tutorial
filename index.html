<meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-E9ZG1KHTVT"></script>
<script src='/scripts/google.js'></script>

<title>Camera Lens Tutorial</title>

<div id="app">
    <canvas id="canvas" @mousedown="mouseDown" @mousemove="mouseMove" @mouseup="mouseUp"></canvas>
    <canvas id="canvas-sensor" @mousedown="mouseDown" @mousemove="mouseMove" @mouseup="mouseUp"
        style="margin-left: 1em;"></canvas>
    <div>
        <label>
            Aperture
            <input type="range" min="0" :max="1" step="0.01" v-model="aperture">
            {{aperture}}
        </label>
        <br>
        <label>
            Sensor size
            <input type="range" min="0.1" :max="3" step="0.1" v-model="sensor.size">
            {{sensor.size}}
        </label>
        <br>
        <label>
            Sensor position
            <input type="range" :min="focalLength*0.99" max="8" step="0.01" v-model="sensor.x">
            {{sensor.x}}
        </label>
        <br>
        <label>
            Lens thickness
            <input type="range" min="0.1" :max="Math.min(5, lens.r*2)" step="0.1" v-model="lens.d">
            {{lens.d}}
        </label>
        <br>
        <label>
            Lens R
            <input type="range" :min="lens.d/2" max="100" step="0.1" v-model="lens.r">
            {{lens.r}}
        </label>
        <br>
        <label>
            Number of rays
            <input type="range" min="1" max="4096" step="1" v-model="rayN">
            {{rayN}}
        </label>
        <br>
        <label>
            Ray width
            <input type="range" min="0.01" max="1.0" step="0.01" v-model="rayWidth">
            {{rayWidth}}
        </label>
        <br>
        <label>
            Canvas scale
            <input type="range" min="0.1" max="100" step="0.1" v-model="scale">
            {{scale}}
        </label>
        <br>
        <label v-for="light in lights">
            <input type="checkbox" v-model="light.enabled">
            Show light {{light.color}}
            <br>
        </label>
    </div>
    <div>
        <details>
            <summary>Debug</summary>
            moving: {{moving}}
            FPS: {{fps}}<br>
        </details>
    </div>

    <h1>Description</h1>
</div>

<script type="module">
    import { createApp } from 'https://unpkg.com/vue@3/dist/vue.esm-browser.js'

    createApp({
        data() {
            return {
                canvas: undefined,
                cx: 0,
                cy: 0,
                scale: 50,
                rayN: 512,
                rayWidth: 0.3,
                lens: {
                    r: 10,
                    d: 0.3,
                    n: 1.5,
                },
                sensor: {
                    x: 4.0,
                    size: 1.0,
                },
                aperture: 1.0,
                lights: [
                    { x: -8, y: -3, r: 0.1, color: "rgba(255, 0, 0, 0.8)", enabled: false },
                    { x: -12, y: -3, r: 0.1, color: "rgba(0, 255, 0, 0.8)", enabled: true },
                    { x: -16, y: -3, r: 0.1, color: "rgba(0, 0, 255, 0.8)", enabled: false },
                ],
                moving: -1,
                fps: 0,
            }
        },
        methods: {
            mouseDown(e) {
                const rect = this.canvas.getBoundingClientRect()
                const x = (e.clientX - rect.left - this.cx) / this.scale;
                const y = (e.clientY - rect.top - this.cy) / this.scale;

                this.lights.forEach((light, idx) => {
                    if (Math.pow(x - light.x, 2) + Math.pow(y - light.y, 2) < Math.pow(light.r * 2, 2)) {
                        this.moving = idx;
                    }
                });
            },
            mouseMove(e) {
                if (this.moving >= 0) {
                    const rect = this.canvas.getBoundingClientRect()
                    const x = (e.clientX - rect.left - this.cx) / this.scale;
                    const y = (e.clientY - rect.top - this.cy) / this.scale;
                    this.lights[this.moving].x = Math.min(x, -this.focalLength * 1.001);
                    this.lights[this.moving].y = y;
                }
            },
            mouseUp(e) {
                this.moving = -1;
            },
        },
        computed: {
            focalLength() {
                return this.lens.r / 2 * (this.lens.n - 1);
            },
            lensSize() {
                const theta = Math.acos((this.lens.r - this.lens.d / 2) / this.lens.r);
                return this.lens.r * Math.sin(theta);
            },
        },
        mounted() {
            //================================
            // Support functions
            //================================
            const getIntersectionRX = (px, py, theta, sx, tx, y, maxR) => {
                const r = (y - py) / Math.sin(theta);
                const x = px + r * Math.cos(theta);
                if (sx <= x && x <= tx) {
                    return r;
                } else {
                    return Math.sign(r) * maxR;
                }
            }

            const getIntersectionRY = (px, py, theta, x, sy, ty, maxR) => {
                const r = (x - px) / Math.cos(theta);
                const y = py + r * Math.sin(theta);
                if (tx <= y && y <= ty) {
                    return r;
                } else {
                    return Math.sign(r) * maxR;
                }
            }

            //================================
            // Canvas setup
            //================================
            const height = 800;

            // Main canvas
            this.canvas = document.getElementById("canvas");
            this.canvas.height = height;
            this.canvas.width = height * 2;
            const offscreen = new OffscreenCanvas(canvas.width, canvas.height);
            const ctx = offscreen.getContext("2d", { alpha: false });
            const mainCtx = this.canvas.getContext("bitmaprenderer");

            const w = this.canvas.width;
            const h = this.canvas.height;
            this.cx = this.canvas.width * 2 / 3;
            this.cy = this.canvas.height / 2;

            // Sensor canvas
            const sensorCanvas = document.getElementById("canvas-sensor");
            sensorCanvas.height = height;
            sensorCanvas.width = height / 8;
            const sensorCanvasCtx = sensorCanvas.getContext("2d");

            // Render callback
            let frames = 0;
            let startTime = new Date().getTime();
            const render = () => {
                // Calculate FPS
                frames += 1;
                let endTime = new Date().getTime();
                if (endTime - startTime >= 1000) {
                    this.fps = frames / (endTime - startTime) * 1000;
                    startTime = endTime;
                    frames = 0;
                }

                //================================
                // Main canvas drawing
                //================================
                const maxR = (w + h) / this.scale; // Long enough

                //--------------------------------
                // Clear canvas
                //--------------------------------
                ctx.reset();
                ctx.fillRect(0, 0, w, h); // background
                ctx.transform(this.scale, 0, 0, this.scale, this.cx, this.cy);
                ctx.globalCompositeOperation = 'lighten';

                //--------------------------------
                // Axes
                //--------------------------------
                ctx.strokeStyle = "white";
                ctx.lineWidth = 0.2 / this.scale;
                // x-axis
                ctx.beginPath();
                ctx.moveTo(-w, 0);
                ctx.lineTo(w, 0);
                ctx.stroke();

                // y-axis
                ctx.beginPath();
                ctx.moveTo(0, -h);
                ctx.lineTo(0, h);
                ctx.stroke();

                //--------------------------------
                // Aperture
                //--------------------------------
                ctx.strokeStyle = "white";
                ctx.lineWidth = 1 / this.scale;
                // upper
                {
                    ctx.beginPath();
                    ctx.moveTo(0, -this.lensSize);
                    ctx.lineTo(0, -this.lensSize * this.aperture);
                    ctx.stroke();
                }
                // lower
                {
                    ctx.beginPath();
                    ctx.moveTo(0, this.lensSize);
                    ctx.lineTo(0, this.lensSize * this.aperture);
                    ctx.stroke();
                }

                //--------------------------------
                // Lights
                //--------------------------------
                let sensorIntersections = new Array(this.lights.length).fill([]);
                // Rays
                this.lights.forEach((light, idx) => {
                    if (!light.enabled) {
                        return;
                    }

                    const x = light.x;
                    const y = light.y;
                    const color = light.color;
                    ctx.strokeStyle = color;

                    let sensorIntersectionsForLight = [];
                    ctx.lineWidth = this.rayWidth / this.scale;
                    for (let i = 0; i < this.rayN; i++) {
                        const theta = 2 * Math.PI * i / this.rayN;
                        let r = maxR;

                        const r0 = - light.x / Math.cos(theta);
                        const y0 = light.y + r0 * Math.sin(theta);
                        const hitLens = r0 > 0 && -this.lensSize < y0 && y0 < this.lensSize;
                        if (hitLens) {
                            r = r0;
                        }
                        const tx = x + r * Math.cos(theta);
                        const ty = y + r * Math.sin(theta);

                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(tx, ty);
                        ctx.stroke();

                        // Ray behind lens
                        const notHitAperture = r0 > 0 && -this.lensSize * this.aperture < y0 && y0 < this.lensSize * this.aperture;
                        if (hitLens && notHitAperture) {
                            const s1 = Math.abs(light.x);
                            const s2 = this.focalLength + this.focalLength * this.focalLength / (s1 - this.focalLength);
                            const ux = s2;
                            const uy = - light.y * (s2 / s1)
                            const theta = Math.atan2(uy - y0, ux - 0);
                            r = maxR;

                            // Record intersection with sensor
                            const rSensor = (this.sensor.x - tx) / Math.cos(theta);
                            const vy = ty + rSensor * Math.sin(theta);
                            const hitSensor = rSensor > 0 && -this.sensor.size < vy && vy < this.sensor.size;
                            if (hitSensor) {
                                r = rSensor;
                                sensorIntersectionsForLight.push(vy);
                            }

                            ctx.beginPath();
                            ctx.moveTo(tx, ty);
                            ctx.lineTo(tx + r * Math.cos(theta), ty + r * Math.sin(theta));
                            ctx.stroke();
                        }
                    }
                    sensorIntersections[idx] = sensorIntersectionsForLight;
                });

                // Source points
                ctx.globalCompositeOperation = 'normal';
                this.lights.forEach((light) => {
                    if (!light.enabled) {
                        return;
                    }

                    {
                        const x = light.x;
                        const y = light.y;
                        const r = light.r;
                        ctx.beginPath();
                        ctx.arc(x, y, r, 0, Math.PI * 2);
                        ctx.lineWidth = 1 / this.scale;
                        ctx.strokeStyle = "black";
                        ctx.stroke();
                    }
                });

                //--------------------------------
                // Lens
                //--------------------------------
                {
                    const r = this.lens.r;
                    const theta = Math.acos((this.lens.r - this.lens.d / 2) / this.lens.r);
                    const y = 0;
                    ctx.lineWidth = 1 / this.scale;
                    ctx.strokeStyle = "white";
                    // Left
                    {
                        const x = this.lens.r - this.lens.d / 2;
                        const startAngle = Math.PI - theta;
                        const endAngle = Math.PI + theta;
                        ctx.beginPath();
                        ctx.arc(x, y, r, startAngle, endAngle);
                        ctx.stroke();
                    }
                    // Right
                    {
                        const x = -(this.lens.r - this.lens.d / 2);
                        const startAngle = - theta;
                        const endAngle = theta;
                        ctx.beginPath();
                        ctx.arc(x, y, r, startAngle, endAngle);
                        ctx.stroke();
                    }
                }
                // Focal point
                {
                    const r = 3 / this.scale;
                    const y = 0;
                    ctx.fillStyle = "white";
                    ctx.strokeStyle = "white";
                    // Left
                    {
                        const x = -this.focalLength;
                        ctx.beginPath();
                        ctx.arc(x, y, r, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                    }
                    // Right
                    {
                        const x = this.focalLength;
                        ctx.beginPath();
                        ctx.arc(x, y, r, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                    }
                }

                //--------------------------------
                // Sensor
                //--------------------------------
                ctx.strokeStyle = "white";
                ctx.lineWidth = 1 / this.scale;
                ctx.beginPath();
                ctx.moveTo(this.sensor.x, this.sensor.size)
                ctx.lineTo(this.sensor.x, -this.sensor.size);
                ctx.stroke();

                //--------------------------------
                // Copy offscreen render result to main canvas
                //--------------------------------
                mainCtx.transferFromImageBitmap(offscreen.transferToImageBitmap());

                //================================
                // Sensor canvas drawing
                //================================
                sensorCanvasCtx.reset();
                sensorCanvasCtx.fillRect(0, 0, h / 4, h); // background
                const sensorCanvasScale = sensorCanvas.height / (this.sensor.size * 2);
                sensorCanvasCtx.transform(sensorCanvasScale * 16, 0, 0, sensorCanvasScale, sensorCanvas.width / 2, sensorCanvas.height / 2);
                sensorCanvasCtx.globalCompositeOperation = 'lighten';

                sensorIntersections.forEach((sensorIntersectionsForLight, idx) => {
                    const color = this.lights[idx].color;
                    sensorCanvasCtx.fillStyle = color;
                    sensorIntersectionsForLight.forEach((y) => {
                        sensorCanvasCtx.beginPath();
                        sensorCanvasCtx.arc(0, y, this.rayWidth / 2 / 50, 0, Math.PI * 2);
                        sensorCanvasCtx.fill();
                    });
                });
            }

            // Render only when data changes
            this.$watch('$data', () => {
                requestAnimationFrame(render);
            }, { deep: true, immediate: true });
        },
    }).mount('#app')
</script>