<meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-E9ZG1KHTVT"></script>
<script src='/scripts/google.js'></script>

<style>
    .container {
        display: grid;
        grid-template-columns: 9fr 1fr;
        gap: 10px;
    }

    .item-main {
        grid-column: 1;
        grid-row: 1;
    }

    .item-sensor {
        grid-column: 2;
        grid-row: 1;
    }

    #stage {
        position: relative;
        display: inline;
    }

    #canvas {
        width: 100%;
        position: absolute;
        z-index: 1;
    }

    #ui {
        position: absolute;
        z-index: 2;
    }

    #canvas-sensor {
        width: 100%;
    }

    svg {
        fill: none;
    }

    .svg-axis {
        stroke-width: 0.005;
        stroke: white;
    }

    .svg-light-source,
    .svg-sensor,
    .svg-line {
        stroke-width: 0.03;
        stroke: white;
    }

    .svg-line-dot {
        stroke-width: 0.02;
        stroke: white;
        stroke-dasharray: 0.1;
    }

    .svg-line-dot-thick {
        stroke-width: 0.005;
        stroke: white;
        stroke-dasharray: 0.1;
    }

    .svg-focal-point {
        fill: white;
    }

    .svg-lens,
    .svg-focal-length,
    .svg-lens-size,
    .svg-aperture,
    .svg-sensor-size {
        fill: white;
        fill-opacity: 0.0;
    }

    .svg-sensor-size:hover,
    .svg-lens-size:hover,
    .svg-aperture:hover,
    .svg-focal-length:hover,
    .svg-lens:hover {
        stroke-width: 0.03;
        stroke: white;
    }
</style>

<title>Simple Camera Lens Simulator</title>

<div id="app">
    <div class="container">
        <div class="item-main" id="stage">
            <canvas id="canvas"></canvas>
            <svg id="ui" :width="width" :height="height" :view-box.camel="viewBoxStr" xmlns="http://www.w3.org/2000/svg"
                @mousemove="mouseMove" @mouseup="mouseUp">
                <!-- Axes -->
                <line class="svg-axis" :x1="viewBox.x" y1="0" :x2="viewBox.x+viewBox.w" y2="0" />
                <line class="svg-axis" x1="0" :y1="-viewBox.y" x2="0" :y2="viewBox.y" />
                <!-- Box -->
                <line class="svg-line" :x1="lens.x" :y1="-boxHeight/2" :x2="lens.x+boxWidth" :y2="-boxHeight/2" />
                <line class="svg-line" :x1="lens.x" :y1="boxHeight/2" :x2="lens.x+boxWidth" :y2="boxHeight/2" />
                <line class="svg-line" :x1="lens.x+boxWidth" :y1="-boxHeight/2" :x2="lens.x+boxWidth"
                    :y2="boxHeight/2" />
                <line class="svg-line" :x1="lens.x" :y1="-boxHeight/2" :x2="lens.x" :y2="-lens.r" />
                <line class="svg-line" :x1="lens.x" :y1="lens.r" :x2="lens.x" :y2="boxHeight/2" />
                <!-- Angle -->
                <g v-if="options.showAngle">
                    <!-- Inside camera -->
                    <line class="svg-line-dot" :x1="sensor.x" :y1="-sensor.size" :x2="lens.x" :y2="-lens.r*aperture" />
                    <line class="svg-line-dot" :x1="sensor.x" :y1="sensor.size" :x2="lens.x" :y2="lens.r*aperture" />
                    <!-- <line class="svg-line-dot-thick" :x1="sensor.x" :y1="-sensor.size" :x2="lens.x" :y2="lens.r*aperture" />
                    <line class="svg-line-dot-thick" :x1="sensor.x" :y1="sensor.size" :x2="lens.x" :y2="-lens.r*aperture" /> -->
                    <!-- Inner -->
                    <line class="svg-line-dot-thick" :x1="focalInfo.focalPos.x" :y1="-focalInfo.focalPos.size"
                        :x2="focalInfo.inner.x" :y2="focalInfo.inner.y" />
                    <line class="svg-line-dot-thick" :x1="focalInfo.focalPos.x" :y1="focalInfo.focalPos.size"
                        :x2="focalInfo.inner.x" :y2="-focalInfo.inner.y" />
                    <line class="svg-line-dot-thick" :x1="lens.x" :y1="-lens.r*aperture" :x2="focalInfo.focalPos.x"
                        :y2="focalInfo.focalPos.size" />
                    <line class="svg-line-dot-thick" :x1="lens.x" :y1="lens.r*aperture" :x2="focalInfo.focalPos.x"
                        :y2="-focalInfo.focalPos.size" />
                    <!-- Outer -->
                    <line class="svg-line-dot" :x1="lens.x" :y1="-lens.r*aperture" :x2="focalInfo.focalPos.x"
                        :y2="-focalInfo.focalPos.size" />
                    <line class="svg-line-dot" :x1="lens.x" :y1="lens.r*aperture" :x2="focalInfo.focalPos.x"
                        :y2="focalInfo.focalPos.size" />
                    <line class="svg-line-dot" :x1="focalInfo.focalPos.x" :y1="-focalInfo.focalPos.size"
                        :x2="focalInfo.outer.x" :y2="-focalInfo.outer.y" />
                    <line class="svg-line-dot" :x1="focalInfo.focalPos.x" :y1="focalInfo.focalPos.size"
                        :x2="focalInfo.outer.x" :y2="focalInfo.outer.y" />
                    <!-- Focal plane -->
                    <line class="svg-line-dot" :x1="focalInfo.focalPos.x" :y1="-focalInfo.focalPos.size"
                        :x2="focalInfo.focalPos.x" :y2="focalInfo.focalPos.size" />
                </g>
                <!-- Focal point -->
                <circle class="svg-focal-point" :cx="lens.x-lens.f" :cy="0" r="0.05" />
                <circle class="svg-focal-point" :cx="lens.x+lens.f" :cy="0" r="0.05" />
                <circle class="svg-focal-length" :cx="lens.x-lens.f" :cy="0" r="0.2"
                    @mousedown="focalLengthMoveHandler" />
                <!-- Light sources position -->
                <g v-for="light in lights">
                    <circle class="svg-light-source" v-if="light.enabled" :cx="light.x" :cy="light.y" r="0.2"
                        :fill="light.color" @mousedown="lightMoveHandler($event, light)" />
                </g>
                <!-- Lens -->
                <rect class="svg-lens" :x="lens.x-lensD/2" :y="-lens.r" :width="lensD" :height="2*lens.r"
                    @mousedown="lensMoveHandler" />
                <circle class="svg-lens-size" :cx="lens.x" :cy="-lens.r" r="0.2" @mousedown="lensSizeMoveHandler" />
                <!-- Aperture -->
                <line class="svg-line" :x1="lens.x" :y1="-lens.r*aperture" :x2="lens.x-Math.max(lensD*2/3, 0.5)"
                    :y2="-lens.r*aperture" />
                <circle class="svg-aperture" :cx="lens.x-Math.max(lensD*2/3, 0.5)" :cy="-lens.r*aperture" r="0.2"
                    @mousedown="apertureMoveHandler" />
                <!-- Sensor -->
                <line class="svg-sensor" :x1="sensor.x" :y1="-sensor.size" :x2="sensor.x" :y2="sensor.size" />
                <circle class="svg-sensor-size" :cx="sensor.x" :cy="-sensor.size" r="0.2"
                    @mousedown="sensorSizeMoveHandler" />
            </svg>
        </div>
        <div class="item-sensor">
            <canvas id="canvas-sensor"></canvas>
        </div>
    </div>

    <div>
        <fieldset>
            <legend>Options</legend>
            <!-- Range sliders -->
            <label>
                Lens refractive index
                <input type="range" :min="1.0" :max="5" step="0.001" v-model.number="lens.n">
                {{lens.n}}
            </label>
            <br>
            <label>
                Number of rays
                <input type="range" min="1" max="4096" step="1" v-model.number="rayN">
                {{rayN}}
            </label>
            <br>
            <label>
                Ray width
                <input type="range" min="0.01" max="1.0" step="0.01" v-model.number="rayWidth">
                {{rayWidth}}
            </label>
            <br>
            <label>
                Canvas scale
                <input type="range" min="0.1" max="100" step="0.1" v-model.number="scale">
                {{scale}}
            </label>
            <!-- Checkboxes -->
            <br>
            <label>
                <input type="checkbox" v-model="options.showAngle">
                Show angle line
            </label>
            <br>
            <label>
                <input type="checkbox" v-model="options.renderOmissionWhileMoving">
                Rendering omission while components moving (for better usability)
            </label>
            <br>
            <label>
                <input type="checkbox" v-model="options.randomRays">
                Random rays
            </label>
            <br>
            <label v-for="light in lights">
                <input type="checkbox" v-model="light.enabled">
                Show light {{light.color}}
                <br>
            </label>
        </fieldset>
    </div>

    <div>
        <h2>Description</h2>
        <p>This is an interactive tool for understanding how the camera works. You can change some conditions and see
            how camera effects change by viewing rays path and image on virtual 1D image sensor.</p>
        <h3>Usage</h3>
        <p>You can change following conditions.</p>
        <ul>
            <li>On canvas (by mouse)</li>
            <ul>
                <li>Light source position</li>
                <li>Lens position (x-axis)</li>
                <li>Aperture</li>
                <li>Sensor size</li>
                <li>Lens size (diameter)</li>
            </ul>
            <li>Out of canvas</li>
            <ul>
                <li>See "Options"</li>
            </ul>
        </ul>
        <p>And you can enable/disable some options.</p>
        <h3>List of common questions about cameras that this tool may help you to understand</h3>
        <ul>
            <li>Q. What is the bokeh (blur effect)?</li>
            <ul>
                <li>A. A not focused circle-shape image. See how focus works by changing lens position.</li>
            </ul>
            <li>Q. How the aperture effects to the bokeh?</li>
            <ul>
                <li>A. Puts multiple light sources with difference distances and see how the size of image changes on
                    virtual image sensor by changing aperture value.</li>
            </ul>
            <li>Q. Why the angle of view changes between different size of image sensors?</li>
            <ul>
                <li>A. See how the image on virtual sensor by changing the sensor size.</li>
            </ul>
            <!-- <li>Q. Why vignetting occurs when using lenses for smaller image sensor?</li>
            <ul>
                <li>A. Lenses for the smaller image sensor (e.g. micro-four-thirds) uses smaller diameter of lenses but
                    same focal length. Put a light source that makes image on the around of corner of image sensor and
                    change lens thickness to see how image cropped (vignetting).
                </li>
            </ul> -->
        </ul>
        <h2>Notice</h2>
        <ul>
            <li>Theoretical correctness is not guaranteed.</li>
            <li>Assume that the camera lens is singe symmetric spherical convex lens. (The real camera lens is composed
                from multiple types of lenses.)</li>
            <li>The rays inside the lens are not visualized correctly. The rays are refracted at the center plane of the
                lens.</li>
            <li>The visual may differ depending on the browser.</li>
            <li>Enabling GPU acceleration is highly recommended.</li>
        </ul>
        <h2>Features</h2>
        <ul>
            <li>Mouse interactive</li>
            <li>Real-time rendering</li>
            <li>Single HTML app (Internet access is needed)</li>
            <!-- <li>Mobile friendly (maybe)</li> -->
        </ul>
        <!-- <h2>Q&A</h2>
        <ul>
            <li>
                Q. xxx.
                <ul>
                    <li>A. xxx.
                    </li>
                </ul>
            </li>
        </ul> -->
        <h3>Used technologies</h3>
        <ul>
            <li>HTML / Javascript</li>
            <li>Vue.js 3</li>
            <li>Canvas API</li>
        </ul>
        <p>
            <a href="https://github.com/monman53/simple-camera-simulator">Source codes (GitHub)</a>
            Any suggestions and issues are welcome.
        </p>
        <h2>Future works</h2>
        <ul>
            <li>Support shutter</li>
            <li>More detail emulation for lens refraction</li>
            <li>Support composite lenses</li>
        </ul>
        <h2>References</h2>
        <ul>
            <li><a href="https://en.wikipedia.org/wiki/Lens">Lens - Wikipedia</a></li>
        </ul>
        <h2>Contacts</h2>
        <ul>
            <li><a href="https://github.com/monman53/simple-camera-lens-simulator">GitHub (This project)</a></li>
            <li><a href="https://github.com/monman53">GitHub (Profile page)</a></li>
            <li><a href="https://twitter.com/monman53">Twitter</a></li>
        </ul>
    </div>
</div>

<script type="module">
    // import { createApp } from 'https://unpkg.com/vue@3/dist/vue.esm-browser.js'
    import { createApp } from 'https://unpkg.com/vue@3/dist/vue.esm-browser.prod.js'

    createApp({
        data() {
            return {
                canvas: undefined,
                sensorCanvas: undefined,
                width: 1600,
                height: 800,
                viewBox: {
                    x: 0,
                    y: 0,
                    w: 0,
                    h: 0,
                },
                scale: 50,
                rayN: 512,
                rayWidth: 0.4,
                lens: {
                    x: -4.0,
                    r: 1.0,
                    f: 3,
                    n: 1.5,
                },
                sensor: {
                    x: 0.0,
                    size: 1.0,
                },
                aperture: 1.0,
                lights: [
                    { x: -9, y: -1, color: "rgba(255, 0, 0, 0.8)", enabled: true },
                    { x: -12, y: -0.5, color: "rgba(0, 255, 0, 0.8)", enabled: true },
                    { x: -20, y: 1, color: "rgba(0, 0, 255, 0.8)", enabled: true },
                ],
                options: {
                    renderOmissionWhileMoving: true,
                    showAngle: false,
                    randomRays: false,
                },
                fps: 0,
                moveHandler: null,
            }
        },
        computed: {
            lensR() {
                const R = this.calcLensR(this.lens.n, this.lens.f, this.lens.r);
                if (R < 0) {
                    // Failed to solve R (no real answer?)
                    return this.lens.r * 1.01;
                }
                console.assert(R > this.lens.r);
                return R;
            },
            lensD() {
                // const theta = Math.asin(this.lens.r / this.lensR);
                // return 2 * this.lensR * (1 - Math.cos(theta));
                return 2 * (this.lensR - Math.sqrt(this.lensR * this.lensR - this.lens.r * this.lens.r));
            },
            boxWidth() {
                return this.sensor.x - this.lens.x + 0.3;
            },
            boxHeight() {
                return Math.max(this.lens.r * 2, this.sensor.size * 2 + 0.8);
            },
            viewBoxStr() {
                return `${this.viewBox.x} ${this.viewBox.y} ${this.viewBox.w} ${this.viewBox.h}`;
            },
            maxR() {
                let maxR2 = 0;
                this.lights.forEach((light) => {
                    const dx = Math.max(Math.abs(this.viewBox.x - light.x), Math.abs(this.viewBox.x + this.viewBox.w - light.x));
                    const dy = Math.max(Math.abs(this.viewBox.y - light.y), Math.abs(this.viewBox.y + this.viewBox.h - light.y));
                    maxR2 = Math.max(dx * dx + dy * dy, maxR2);
                });
                return Math.sqrt(maxR2) * 2;
                // TODO: Check if long enough (Use as length of infinity ray)
            },
            focalInfo() {
                const f = this.lens.f;
                const b = this.sensor.x - this.lens.x;
                const a = f * b / (b - f);

                const focalPosX = this.lens.x - a;
                const focalPosSize = this.sensor.size * (a / b);

                const [innerX, innerY] = this.extendSegment(this.lens.x, -this.lens.r * this.aperture, focalPosX, -focalPosSize);
                const [outerX, outerY] = this.extendSegment(this.lens.x, -this.lens.r * this.aperture, focalPosX, focalPosSize);

                return {
                    focalPos: { x: focalPosX, size: focalPosSize },
                    inner: { x: innerX, y: innerY },
                    outer: { x: outerX, y: outerY },
                }
            },
        },
        watch: {
            'lens.n'(newN, oldN) {
                if (this.calcLensR(newN, this.lens.f, this.lens.r) < 0) {
                    this.lens.n = oldN;
                }
            },
            'lens.r'(newR, oldR) {
                if (this.calcLensR(this.lens.n, this.lens.f, newR) < 0) {
                    this.lens.r = oldR;
                }
            }
        },
        methods: {
            calcLensR(n, f, r) {
                // This formula is made from maker's formula and d = 2(R-sqrt(R^2-r^2))
                const func = (R) => {
                    let res = 0;
                    res += n * n * Math.pow(R, 4);
                    res += - 4 * n * (n - 1) * f * Math.pow(R, 3);
                    res += 4 * (n - 1) * (n - 1) * f * f * (1 - (n - 1) * (n - 1)) * R * R;
                    res += 4 * Math.pow(n - 1, 4) * f * f * r * r;

                    return res;
                };

                // Derivative of func
                const funcc = (R) => {
                    let res = 0;
                    res += 4 * n * n * Math.pow(R, 3);
                    res += - 12 * n * (n - 1) * f * Math.pow(R, 2);
                    res += 8 * (n - 1) * (n - 1) * f * f * (1 - (n - 1) * (n - 1)) * R;
                    return res;
                };

                // Solve func(R) = 0 by Newton' method
                let R = 10 * n; // NOTICE: Very heuristic
                for (let i = 0; i < 100; i++) {
                    // console.log(R, func(R), funcc(R))
                    R = R - func(R) / funcc(R);

                    // Validation R with desired focal length
                    // Calculate focal length by lens maker's formula
                    const d = 2 * (R - Math.sqrt(R * R - r * r));
                    const desiredLensF = f;
                    const actualLensF = 1.0 / (2 * (n - 1) / R - (n - 1) * (n - 1) * d / (n * R * R));
                    // console.log(desiredLensF, actualLensF);

                    const absError = Math.abs(desiredLensF - actualLensF);
                    const relError = absError / desiredLensF;
                    if (relError < 0.0001) {
                        return R;
                    }
                }

                // Failed
                return -1.0;
            },
            getMousePosition(e) {
                const rect = this.canvas.getBoundingClientRect()
                const xPix = e.clientX - rect.left;
                const yPix = e.clientY - rect.top;
                const x = xPix / this.scale + this.viewBox.x;
                const y = yPix / this.scale + this.viewBox.y;
                return [x, y];
            },
            lightMoveHandler(e, light) {
                const [sx, sy] = this.getMousePosition(e);
                const x = light.x;
                const y = light.y;

                const handler = (e) => {
                    const [tx, ty] = this.getMousePosition(e);
                    const nx = x + (tx - sx);
                    const ny = y + (ty - sy);
                    const maxX = this.lens.x - this.lens.f * 1.01;
                    light.x = maxX < nx ? maxX : nx;
                    light.y = ny;
                };

                this.moveHandler = handler;
            },
            lensMoveHandler(e) {
                const [sx, sy] = this.getMousePosition(e);
                const x = this.lens.x;
                const handler = (e) => {
                    const [tx, ty] = this.getMousePosition(e);
                    let nx = x + (tx - sx);
                    this.lights.forEach((light) => {
                        if (light.enabled) {
                            const minX = light.x + 1.01 * this.lens.f;
                            if (nx < minX) {
                                nx = minX;
                            }
                        }
                    });
                    if (nx > this.sensor.x) {
                        nx = this.sensor.x;
                    }
                    this.lens.x = nx;
                };

                this.moveHandler = handler;
            },
            focalLengthMoveHandler(e) {
                const [sx, sy] = this.getMousePosition(e);
                const x = this.lens.x - this.lens.f;
                const handler = (e) => {
                    const [tx, ty] = this.getMousePosition(e);
                    let nx = x + (tx - sx);
                    // Doesn't go left than light sources
                    this.lights.forEach((light) => {
                        if (light.enabled) {
                            const minX = light.x + 0.01;
                            if (nx < minX) {
                                nx = minX;
                            }
                        }
                    });
                    // Doesn't collision to lens
                    if (nx > this.lens.x - 0.01) {
                        nx = this.lens.x - 0.01;
                    }

                    const nLensF = this.lens.x - nx;
                    const nLensR = this.calcLensR(this.lens.n, nLensF, this.lens.r);
                    if (this.lens.r * 1.2 < nLensR) {
                        this.lens.f = nLensF;
                    }
                };

                this.moveHandler = handler;
            },
            lensSizeMoveHandler(e) {
                const [sx, sy] = this.getMousePosition(e);
                const y = -this.lens.r
                const handler = (e) => {
                    const [tx, ty] = this.getMousePosition(e);
                    let ny = y + (ty - sy);
                    if (ny > -0.01) {
                        ny = -0.01;
                    }
                    const nLensSize = -ny;
                    const nLensR = this.calcLensR(this.lens.n, this.lens.f, nLensSize);
                    if (0 < nLensR) {
                        this.lens.r = nLensSize;
                    }
                };

                this.moveHandler = handler;
            },
            sensorSizeMoveHandler(e) {
                const [sx, sy] = this.getMousePosition(e);
                const y = -this.sensor.size;

                const handler = (e) => {
                    const [tx, ty] = this.getMousePosition(e);
                    const ny = y + (ty - sy);
                    const maxY = -0.1;
                    this.sensor.size = maxY < ny ? -maxY : -ny;
                };

                this.moveHandler = handler;
            },
            apertureMoveHandler(e) {
                const [sx, sy] = this.getMousePosition(e);
                const y = -this.lens.r * this.aperture;

                const handler = (e) => {
                    const [tx, ty] = this.getMousePosition(e);
                    const ny = y + (ty - sy);
                    if (0 < ny) {
                        this.aperture = 0;
                    } else if (ny < -this.lens.r) {
                        this.aperture = 1;
                    } else {
                        this.aperture = -ny / this.lens.r;
                    }
                };

                this.moveHandler = handler;
            },
            mouseMove(e) {
                if (this.moveHandler) {
                    this.moveHandler(e);
                }
            },
            mouseUp(e) {
                this.moveHandler = null;
                this.moving = -1;
            },
            resize() {
                this.width = this.canvas.getBoundingClientRect().width;
                this.height = this.width * (5 / 10);
                this.canvas.width = this.width;
                this.canvas.height = this.height;
                this.sensorCanvas.width = this.sensorCanvas.getBoundingClientRect().width;
                this.sensorCanvas.height = this.height;
                this.sensorCanvas.style.width = this.sensorCanvas.getBoundingClientRect().width;
                this.sensorCanvas.style.height = this.canvas.getBoundingClientRect().height;
            },
            extendSegment(sx, sy, tx, ty) {
                const theta = Math.atan2(ty - sy, tx - sx);
                const ntx = sx + this.maxR * Math.cos(theta);
                const nty = sy + this.maxR * Math.sin(theta);
                return [ntx, nty];
            },
        },
        mounted() {
            //================================
            // Support functions
            //================================
            const getIntersectionX = (px, py, theta, minX, maxX, y, maxR) => {
                const sin = Math.sin(theta);
                const cos = Math.cos(theta);
                const r = (y - py) / sin;
                const x = px + r * cos;
                if (r >= 0 && minX <= x && x <= maxX) {
                    return [true, x, y, r];
                } else {
                    return [false, px + maxR * cos, py + maxR * sin, maxR];
                }
            }

            const getIntersectionY = (px, py, theta, x, minY, maxY, maxR) => {
                const sin = Math.sin(theta);
                const cos = Math.cos(theta);
                const r = (x - px) / cos;
                const y = py + r * sin;
                if (r >= 0 && minY <= y && y <= maxY) {
                    return [true, x, y, r];
                } else {
                    return [false, px + maxR * cos, py + maxR * sin, maxR];
                }
            }

            const getIntersectionBox = (cx, cy, theta, maxR, isInner) => {
                // Front
                if (!isInner) {
                    const [hit0, x0, y0, r0] = getIntersectionY(cx, cy, theta, this.lens.x, -this.boxHeight / 2, this.boxHeight / 2, maxR);
                    if (hit0 && r0 > 0) {
                        // NOTICE: Assume all rays passes left to right
                        // r0 > 0 condition is for inner rays.
                        return [hit0, x0, y0, r0];
                    }
                }
                // Top
                const [hit1, x1, y1, r1] = getIntersectionX(cx, cy, theta, this.lens.x, this.lens.x + this.boxWidth, -this.boxHeight / 2, maxR);
                if (hit1 && isInner) {
                    return [hit1, x1, y1, r1];
                }
                // Bottom
                const [hit2, x2, y2, r2] = getIntersectionX(cx, cy, theta, this.lens.x, this.lens.x + this.boxWidth, this.boxHeight / 2, maxR);
                if (hit2 && isInner) {
                    return [hit2, x2, y2, r2];
                }

                if (!isInner) {
                    if (r1 < r2) {
                        return [hit1, x1, y1];
                    } else {
                        return [hit2, x2, y2];
                    }
                }

                // Behind the sensor
                const [hit3, x3, y3, r3] = getIntersectionY(cx, cy, theta, this.lens.x + this.boxWidth, -this.boxHeight / 2, this.boxHeight / 2, maxR);
                if (hit3) {
                    return [hit3, x3, y3, r3];
                }

                // Return closest intersection
                if (r1 <= r2 && r1 <= r3) {
                    return [hit1, x1, y1];
                } else if ((r2 <= r1 && r2 <= r3)) {
                    return [hit2, x2, y2];
                } else {
                    return [hit3, x3, y3];
                }
            }

            //================================
            // Canvas setup
            //================================
            // Main canvas
            this.canvas = document.getElementById("canvas");

            // Sensor canvas
            this.sensorCanvas = document.getElementById("canvas-sensor");
            const sensorCanvasCtx = this.sensorCanvas.getContext("2d");

            this.resize();
            window.addEventListener("resize", this.resize);

            // Prepare offscreen canvas
            const offscreen = new OffscreenCanvas(this.canvas.width, this.canvas.height);
            const ctx = offscreen.getContext("2d", { alpha: false });
            const mainCtx = this.canvas.getContext("bitmaprenderer");

            // Define scale factor
            this.scale = this.canvas.height / (this.sensor.size * 16);

            //================================
            // Render callback function
            //================================
            let frames = 0;
            let startTime = new Date().getTime();
            const render = () => {
                // Calculate FPS
                frames += 1;
                let endTime = new Date().getTime();
                if (endTime - startTime >= 1000) {
                    this.fps = frames / (endTime - startTime) * 1000;
                    startTime = endTime;
                    frames = 0;
                }

                //================================
                // Main canvas drawing
                //================================
                const w = this.canvas.width;
                const h = this.canvas.height;

                this.viewBox.w = w / this.scale;
                this.viewBox.h = h / this.scale;
                this.viewBox.x = -0.95 * this.viewBox.w
                this.viewBox.y = -this.viewBox.h / 2;

                offscreen.width = w;
                offscreen.height = h;

                //--------------------------------
                // Clear canvas
                //--------------------------------
                ctx.reset();
                ctx.transform(this.scale, 0, 0, this.scale, -this.viewBox.x * this.scale, -this.viewBox.y * this.scale);
                ctx.fillRect(this.viewBox.x, this.viewBox.y, this.viewBox.w, this.viewBox.h); // background
                ctx.globalCompositeOperation = 'lighten';

                //--------------------------------
                // Rays
                //--------------------------------
                let sensorIntersections = new Array(this.lights.length).fill([]);
                this.lights.forEach((light, idx) => {
                    if (!light.enabled) {
                        return;
                    }

                    const x = light.x;
                    const y = light.y;
                    const color = light.color;
                    ctx.strokeStyle = color;

                    // Find a range that needs intersection calculation
                    const thetaMin = Math.min(
                        Math.atan2(-this.boxHeight / 2 - y, this.lens.x - x),// top left
                        Math.atan2(-this.boxHeight / 2 - y, this.lens.x + this.boxWidth - x) // top right
                    );
                    const thetaMax = Math.max(
                        Math.atan2(this.boxHeight / 2 - y, this.lens.x - x), // bottom left
                        Math.atan2(this.boxHeight / 2 - y, this.lens.x + this.boxWidth - x) // bottom right
                    );


                    // Find image position (ux, uy) of the light source
                    const s1 = this.lens.x - light.x;
                    const s2 = this.lens.f * s1 / (s1 - this.lens.f);
                    const ux = s2;
                    const uy = -light.y * (s2 / s1)

                    // Draw rays
                    let sensorIntersectionsForLight = [];
                    ctx.lineWidth = this.rayWidth / this.scale;
                    const itr = this.options.renderOmissionWhileMoving && this.moveHandler ? Math.min(512, this.rayN) : this.rayN;
                    for (let i = 0; i < itr; i++) {
                        // Draw outer ray
                        const theta = this.options.randomRays
                            ? 2 * Math.PI * Math.random() - Math.PI
                            : 2 * Math.PI * i / itr - Math.PI; // -pi <= theta < pi

                        // Pruning intersection check of left oriented rays for optimization
                        if (theta < thetaMin || thetaMax < theta) {
                            // Draw light source to infinity ray
                            ctx.beginPath();
                            ctx.moveTo(x, y);
                            ctx.lineTo(x + this.maxR * Math.cos(theta), y + this.maxR * Math.sin(theta));
                            ctx.stroke();
                            continue;
                        }

                        // Check intersection with lens
                        const [hitLens, tx, ty] = getIntersectionY(x, y, theta, this.lens.x, -this.lens.r, this.lens.r, this.maxR);

                        if (!hitLens) {
                            // Draw rays don't enter into the lens
                            const [hitBox, tx, ty] = getIntersectionBox(x, y, theta, this.maxR, false);
                            ctx.beginPath();
                            ctx.moveTo(x, y);
                            ctx.lineTo(tx, ty);
                            ctx.stroke();
                            continue;
                        }

                        // Draw light to lens ray
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(tx, ty);
                        ctx.stroke();

                        // Draw inner ray
                        const notHitAperture = -this.lens.r * this.aperture < ty && ty < this.lens.r * this.aperture;
                        if (notHitAperture) {
                            // Calculate refraction direction (phi)
                            const phi = Math.atan2(uy - ty, ux);

                            // Check intersection to the sensor
                            const [hitSensor, vx, vy] = getIntersectionY(tx, ty, phi, this.sensor.x, -this.sensor.size, this.sensor.size, this.maxR, false);

                            // Draw lens to sensor ray
                            if (hitSensor) {
                                ctx.beginPath();
                                ctx.moveTo(tx, ty);
                                ctx.lineTo(vx, vy);
                                ctx.stroke();
                            } else {
                                const [hitBox, vx, vy] = getIntersectionBox(tx, ty, phi, this.maxR, true);
                                console.assert(hitBox); // Inner rays should always hit to the box
                                ctx.beginPath();
                                ctx.moveTo(tx, ty);
                                ctx.lineTo(vx, vy);
                                ctx.stroke();
                            }

                            // Record intersection
                            if (hitSensor) {
                                sensorIntersectionsForLight.push(vy);
                                continue;
                            }
                        }
                    }
                    sensorIntersections[idx] = sensorIntersectionsForLight;
                });

                //--------------------------------
                // Camera components
                //--------------------------------
                ctx.lineWidth = 1 / this.scale;
                ctx.strokeStyle = "white";
                ctx.fillStyle = "white";

                //--------------------------------
                // Lens
                //--------------------------------
                {
                    const r = this.lensR;
                    const d = this.lensD;
                    const theta = Math.acos((r - d / 2) / r);
                    const y = 0;
                    // Left
                    {
                        const x = this.lens.x + (r - d / 2);
                        const startAngle = Math.PI - theta;
                        const endAngle = Math.PI + theta;
                        ctx.beginPath();
                        ctx.arc(x, y, r, startAngle, endAngle);
                        ctx.stroke();
                    }
                    // Right
                    {
                        const x = this.lens.x - (r - d / 2);
                        const startAngle = - theta;
                        const endAngle = theta;
                        ctx.beginPath();
                        ctx.arc(x, y, r, startAngle, endAngle);
                        ctx.stroke();
                    }
                }

                //--------------------------------
                // Aperture
                //--------------------------------
                // upper
                {
                    ctx.beginPath();
                    ctx.moveTo(this.lens.x, -this.lens.r);
                    ctx.lineTo(this.lens.x, -this.lens.r * this.aperture);
                    ctx.stroke();
                }
                // lower
                {
                    ctx.beginPath();
                    ctx.moveTo(this.lens.x, this.lens.r);
                    ctx.lineTo(this.lens.x, this.lens.r * this.aperture);
                    ctx.stroke();
                }

                //--------------------------------
                // Copy offscreen render result to main canvas
                //--------------------------------
                mainCtx.transferFromImageBitmap(offscreen.transferToImageBitmap());

                //================================
                // Sensor canvas drawing
                //================================
                sensorCanvasCtx.reset();
                sensorCanvasCtx.fillRect(0, 0, this.sensorCanvas.width, this.sensorCanvas.height); // background
                const sensorCanvasScale = this.sensorCanvas.height / (this.sensor.size * 2);
                sensorCanvasCtx.transform(8192, 0, 0, sensorCanvasScale, this.sensorCanvas.width / 2, this.sensorCanvas.height / 2);
                sensorCanvasCtx.globalCompositeOperation = 'lighten';

                sensorIntersections.forEach((sensorIntersectionsForLight, idx) => {
                    const color = this.lights[idx].color;
                    sensorCanvasCtx.fillStyle = color;
                    sensorIntersectionsForLight.forEach((y) => {
                        sensorCanvasCtx.beginPath();
                        sensorCanvasCtx.arc(0, y, this.rayWidth / 2 / 50, 0, Math.PI * 2);
                        sensorCanvasCtx.fill();
                    });
                });
            }

            // Render only when data changed or window resized
            this.$watch('$data', () => {
                requestAnimationFrame(render);
            }, { deep: true, immediate: true });
            window.addEventListener("resize", render);
        },
    }).mount('#app')
</script>