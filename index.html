<meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-E9ZG1KHTVT"></script>
<script src='/scripts/google.js'></script>

<style>
    .container {
        display: grid;
        grid-template-columns: 9fr 1fr;
        gap: 10px;
    }

    .item-main {
        grid-column: 1;
        grid-row: 1;
    }

    .item-sensor {
        grid-column: 2;
        grid-row: 1;
    }

    #stage {
        position: relative;
        display: inline;
    }

    #canvas {
        width: 100%;
        position: absolute;
        z-index: 1;
    }

    #ui {
        position: absolute;
        z-index: 2;
        user-select: none;
    }

    #info {
        position: absolute;
        z-index: 3;
        padding: 0.5em;
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        /* user-select: none; */
    }

    #canvas-sensor {
        width: 100%;
    }

    svg {
        fill: none;
    }

    .svg-axis {
        stroke-width: 0.06;
        stroke: white;
    }

    .svg-light-source,
    .svg-sensor,
    .svg-line {
        stroke-width: 0.3;
        stroke: white;
    }

    .svg-line-dot {
        stroke-width: 0.3;
        stroke: white;
        stroke-dasharray: 1.2;
    }

    .svg-line-dot-thick {
        stroke-width: 0.06;
        stroke: white;
        stroke-dasharray: 1.2;
    }

    .svg-focal-point {
        fill: white;
    }

    .svg-hover {
        fill: white;
        fill-opacity: 0.0;
    }

    .svg-hover:hover {
        stroke-width: 0.4;
        stroke: white;
    }
</style>

<title>Simple Camera Lens Simulator</title>

<div id="app">
    <div class="container">
        <div class="item-main" id="stage">
            <canvas id="canvas"></canvas>
            <svg id="ui" :width="width" :height="height" :view-box.camel="viewBoxStr" xmlns="http://www.w3.org/2000/svg"
                @mousemove="mouseMove" @mouseup="mouseUp" @dblclick="addLightSource($event, true)">
                <!-- Axes -->
                <g v-if="options.showAxes">
                    <line class="svg-axis" :x1="viewBox.x" y1="0" :x2="viewBox.x+viewBox.w" y2="0" />
                    <line class="svg-axis" x1="0" :y1="-viewBox.y" x2="0" :y2="viewBox.y" />
                </g>
                <!-- Body -->
                <g v-if="options.showBody">
                    <line class="svg-line" :x1="lens.x" :y1="-bodyHeight/2" :x2="lens.x+bodyWidth"
                        :y2="-bodyHeight/2" />
                    <line class="svg-line" :x1="lens.x" :y1="bodyHeight/2" :x2="lens.x+bodyWidth" :y2="bodyHeight/2" />
                    <line class="svg-line" :x1="lens.x+bodyWidth" :y1="-bodyHeight/2" :x2="lens.x+bodyWidth"
                        :y2="bodyHeight/2" />
                    <line class="svg-line" :x1="lens.x" :y1="-bodyHeight/2" :x2="lens.x" :y2="-lens.r" />
                    <line class="svg-line" :x1="lens.x" :y1="lens.r" :x2="lens.x" :y2="bodyHeight/2" />
                </g>
                <!-- Angle -->
                <g v-if="options.showAngle && options.showBody && options.showLens">
                    <!-- Inside camera -->
                    <line class="svg-line-dot" :x1="sensor.x" :y1="-sensor.size/2" :x2="lens.x"
                        :y2="-effectiveLensRadius" />
                    <line class="svg-line-dot" :x1="sensor.x" :y1="sensor.size/2" :x2="lens.x"
                        :y2="effectiveLensRadius" />
                    <!-- <line class="svg-line-dot-thick" :x1="sensor.x" :y1="-sensor.size/2" :x2="lens.x" :y2="effectiveLensRadius" />
                    <line class="svg-line-dot-thick" :x1="sensor.x" :y1="sensor.size/2" :x2="lens.x" :y2="-effectiveLensRadius" /> -->
                    <!-- Inner -->
                    <line class="svg-line-dot-thick" :x1="focalInfo.focalPos.x" :y1="-focalInfo.focalPos.size"
                        :x2="focalInfo.inner.x" :y2="focalInfo.inner.y" />
                    <line class="svg-line-dot-thick" :x1="focalInfo.focalPos.x" :y1="focalInfo.focalPos.size"
                        :x2="focalInfo.inner.x" :y2="-focalInfo.inner.y" />
                    <line class="svg-line-dot-thick" :x1="lens.x" :y1="-effectiveLensRadius" :x2="focalInfo.focalPos.x"
                        :y2="focalInfo.focalPos.size" />
                    <line class="svg-line-dot-thick" :x1="lens.x" :y1="effectiveLensRadius" :x2="focalInfo.focalPos.x"
                        :y2="-focalInfo.focalPos.size" />
                    <!-- Outer -->
                    <line class="svg-line-dot" :x1="lens.x" :y1="-effectiveLensRadius" :x2="focalInfo.focalPos.x"
                        :y2="-focalInfo.focalPos.size" />
                    <line class="svg-line-dot" :x1="lens.x" :y1="effectiveLensRadius" :x2="focalInfo.focalPos.x"
                        :y2="focalInfo.focalPos.size" />
                    <line class="svg-line-dot" :x1="focalInfo.focalPos.x" :y1="-focalInfo.focalPos.size"
                        :x2="focalInfo.outer.x" :y2="-focalInfo.outer.y" />
                    <line class="svg-line-dot" :x1="focalInfo.focalPos.x" :y1="focalInfo.focalPos.size"
                        :x2="focalInfo.outer.x" :y2="focalInfo.outer.y" />
                    <!-- Focal plane -->
                    <line class="svg-line-dot" :x1="focalInfo.focalPos.x" :y1="-focalInfo.focalPos.size"
                        :x2="focalInfo.focalPos.x" :y2="focalInfo.focalPos.size" />
                </g>
                <!-- Light sources position -->
                <g v-for="(light, idx) in lights">
                    <circle class="svg-light-source" v-if="light.enabled" :cx="light.x" :cy="light.y" :r="uiCircleR"
                        :style="`fill:${light.color};`" @mousedown="lightMoveHandler($event, light)"
                        @dblclick="deleteLightSource($event, idx)" />
                </g>
                <!-- Lens -->
                <g v-if="options.showLens">
                    <path class="svg-line"
                        :d="`M ${lens.x} ${-lens.r} A ${lensR} ${lensR} 0 0 0 ${lens.x} ${lens.r}`" />
                    <path class="svg-line"
                        :d="`M ${lens.x} ${-lens.r} A ${lensR} ${lensR} 0 0 1 ${lens.x} ${lens.r}`" />
                    <!-- Move -->
                    <rect class="svg-hover" :x="lens.x-lensD/2" :y="-lens.r" :width="lensD" :height="2*lens.r"
                        @mousedown="lensMoveHandler" />
                    <circle class="svg-hover" :cx="lens.x" :cy="-lens.r" :r="uiCircleR"
                        @mousedown="lensSizeMoveHandler" />
                    <!-- Thickness -->
                    <circle class="svg-hover" :cx="lens.x-lensD/2" :cy="0" :r="uiCircleR"
                        @mousedown="lensThicknessMoveHandler" />
                    <!-- Focal point -->
                    <circle class="svg-focal-point" :cx="lens.x-lens.f" :cy="0" :r="uiCircleR/3" />
                    <circle class="svg-focal-point" :cx="lens.x+lens.f" :cy="0" :r="uiCircleR/3" />
                    <circle class="svg-hover" :cx="lens.x-lens.f" :cy="0" r="2.4" @mousedown="focalLengthMoveHandler" />
                </g>
                <!-- Aperture -->
                <g v-if="options.showAperture">
                    <line class="svg-line" :x1="lens.x" :y1="-lens.r" :x2="lens.x" :y2="-effectiveLensRadius" />
                    <line class="svg-line" :x1="lens.x" :y1="lens.r" :x2="lens.x" :y2="effectiveLensRadius" />
                    <!-- UI -->
                    <line class="svg-line" :x1="lens.x" :y1="-effectiveLensRadius" :x2="lens.x-Math.max(lensD*2/3, 0.5)"
                        :y2="-effectiveLensRadius" v-if="options.showApertureGuide" />
                    <circle class="svg-hover" :cx="lens.x-Math.max(lensD*2/3, 0.5)" :cy="-effectiveLensRadius"
                        :r="uiCircleR" @mousedown="apertureMoveHandler" />
                </g>
                <!-- Sensor -->
                <g v-if="options.showBody">
                    <line class="svg-sensor" :x1="sensor.x" :y1="-sensor.size/2" :x2="sensor.x" :y2="sensor.size/2" />
                    <circle class="svg-hover" :cx="sensor.x" :cy="-sensor.size/2" :r="uiCircleR"
                        @mousedown="sensorSizeMoveHandler" />
                </g>
            </svg>
            <div id="info" v-if="options.showInfo">
                Focal length: {{humanReadable(lens.f)}} mm<br>
                f-number: {{humanReadable(fNumber)}}<br></span>
                <span v-if="options.showBody">Sensor size: {{humanReadable(sensor.size)}}<br></span>
                Lens refractive index: {{humanReadable(lens.n)}}<br>
                Lens radius: {{humanReadable(lens.r)}} mm<br>
                Lens thickness: {{humanReadable(lensD)}} mm<br>
                Lens curvature radius: {{humanReadable(lensR)}} mm<br>
                Lens position: {{humanReadable(lens.x)}} mm<br>
            </div>
        </div>
        <div class="item-sensor">
            <canvas id="canvas-sensor"></canvas>
        </div>
    </div>

    <div>
        <fieldset>
            <legend>Options</legend>
            <label>
                <button @click="addLightSource(false)">Add light sources</button>
                <span :style="`color: hsl(${newLight.hue}, 100%, 50%)`"> â–ˆ </span>
                <input type="range" min="0" max="360" step="0.01" v-model.number="newLight.hue">
                <button @click="newLight.hue=0">Red</button>
                <button @click="newLight.hue=120">Green</button>
                <button @click="newLight.hue=240">Blue</button>
                <br>
            </label>
            <!-- Checkboxes -->
            <label v-if="options.showBody">
                <input type="checkbox" v-model="options.showAngle">
                Show angle line
                <br>
            </label>
            <label>
                <input type="checkbox" v-model="options.useIdealLens">
                Use ideal lens
                <br>
            </label>
            <!-- Range sliders -->
            <label>
                Number of rays
                <input type="range" min="1" max="4096" step="1" v-model.number="rayN">
                {{rayN}}
                <br>
            </label>
            <label>
                Ray width
                <input type="range" min="0.001" max="0.5" step="0.001" v-model.number="rayWidth">
                {{rayWidth}}
                <br>
            </label>
            <details>
                <summary>Advanced</summary>
                <label>
                    Lens move sensitivity
                    <input type="range" min="1" max="32" step="1" v-model.number="lensMoveSensitivity">
                    {{lensMoveSensitivity}}
                    <br>
                </label>
                <label>
                    Canvas scale
                    <input type="range" min="0.1" max="10" step="0.001" v-model.number="scale">
                    {{scale}}
                    <br>
                </label>
                <label>
                    <input type="checkbox" v-model="options.showAxes">
                    Show axes
                    <br>
                </label>
                <label>
                    <input type="checkbox" v-model="options.showBody">
                    Show camera body
                    <br>
                </label>
                <label>
                    <input type="checkbox" v-model="options.showLens">
                    Show lens
                    <br>
                </label>
                <label>
                    <input type="checkbox" v-model="options.showAperture">
                    Show aperture
                    <br>
                </label>
                <label>
                    <input type="checkbox" v-model="options.showApertureGuide">
                    Show aperture guide
                    <br>
                </label>
                <label>
                    <input type="checkbox" v-model="options.renderOmissionWhileMoving">
                    Rendering omission while components moving (for better usability)
                    <br>
                </label>
                <label>
                    <input type="checkbox" v-model="options.showInfo">
                    Show info
                    <br>
                </label>
                <label>
                    <input type="checkbox" v-model="options.randomRays">
                    Random rays
                    <br>
                </label>
            </details>
        </fieldset>
    </div>

    <div>
        <h2>Description</h2>
        <p>This is an interactive tool for understanding how the camera works. You can change some conditions and see
            how camera effects change by viewing rays path and image on virtual 1D image sensor.</p>
        <h3>Usage</h3>
        <p>You can change following conditions.</p>
        <ul>
            <li>On canvas (by mouse)</li>
            <ul>
                <li>Light source position</li>
                <li>Aperture</li>
                <li>Lens position (x-axis)</li>
                <li>Lens thickness</li>
                <li>Lens size (diameter)</li>
                <li>Sensor size</li>
            </ul>
            <li>Out of canvas</li>
            <ul>
                <li>See "Options"</li>
            </ul>
        </ul>
        <p>And you can enable/disable some options.</p>
        <h3>List of common questions about cameras that this tool may help you to understand</h3>
        <ul>
            <li>Q. What is the bokeh (blur effect)?</li>
            <ul>
                <li>A. A not focused circle-shape image. See how focus works by changing lens position.</li>
            </ul>
            <li>Q. How the aperture effects to the bokeh?</li>
            <ul>
                <li>A. Puts multiple light sources with difference distances and see how the size of image changes on
                    virtual image sensor by changing aperture value.</li>
            </ul>
            <li>Q. Why the angle of view changes between different size of image sensors?</li>
            <ul>
                <li>A. See how the image on virtual sensor by changing the sensor size.</li>
            </ul>
            <!-- <li>Q. Why vignetting occurs when using lenses for smaller image sensor?</li>
            <ul>
                <li>A. Lenses for the smaller image sensor (e.g. micro-four-thirds) uses smaller diameter of lenses but
                    same focal length. Put a light source that makes image on the around of corner of image sensor and
                    change lens thickness to see how image cropped (vignetting).
                </li>
            </ul> -->
        </ul>
        <h2>Notice</h2>
        <ul>
            <li>Theoretical correctness is not guaranteed.</li>
            <li>Assume that the camera lens is singe symmetric spherical convex lens. (The real camera lens is composed
                from multiple types of lenses.)</li>
            <li>The rays inside the lens are not visualized correctly. The rays are refracted at the center plane of the
                lens.</li>
            <li>The visual may differ depending on the browser.</li>
            <li>Enabling GPU acceleration is highly recommended.</li>
        </ul>
        <h2>Features</h2>
        <ul>
            <li>Mouse interactive</li>
            <li>Real-time rendering</li>
            <li>Single HTML app (Internet access is needed)</li>
            <!-- <li>Mobile friendly (maybe)</li> -->
        </ul>
        <!-- <h2>Q&A</h2>
        <ul>
            <li>
                Q. xxx.
                <ul>
                    <li>A. xxx.
                    </li>
                </ul>
            </li>
        </ul> -->
        <h3>Used technologies</h3>
        <ul>
            <li>HTML / Javascript</li>
            <li>Vue.js 3</li>
            <li>Canvas API</li>
        </ul>
        <p>
            <a href="https://github.com/monman53/simple-camera-simulator">Source codes (GitHub)</a>
            Any suggestions and issues are welcome.
        </p>
        <h2>Future works</h2>
        <ul>
            <li>Support shutter</li>
            <li>More detail emulation for lens refraction</li>
            <li>Support composite lenses</li>
        </ul>
        <h2>References</h2>
        <ul>
            <li><a href="https://en.wikipedia.org/wiki/Lens">Lens - Wikipedia</a></li>
        </ul>
        <h2>Contacts</h2>
        <ul>
            <li><a href="https://github.com/monman53/simple-camera-simulator">GitHub (This project)</a></li>
            <li><a href="https://github.com/monman53">GitHub (Profile page)</a></li>
            <li><a href="https://twitter.com/monman53">Twitter</a></li>
        </ul>
    </div>
</div>

<script type="module">
    // import { createApp } from 'https://unpkg.com/vue@3/dist/vue.esm-browser.js'
    import { createApp, toRaw } from 'https://unpkg.com/vue@3/dist/vue.esm-browser.prod.js'

    // TODO:
    // Cannot calculate n around lensD == lens.r.
    // This problem is unsolved.
    // We use maximum lensD == maxLesD * lens.r here for workaround.
    const maxLensD = 0.5 * 2;
    const minLensD = 0.05 * 2;

    const lightAlpha = 0.5;

    createApp({
        data() {
            return {
                canvas: undefined,
                sensorCanvas: undefined,
                width: 1600,
                height: 800,
                viewBox: {
                    x: 0,
                    y: 0,
                    w: 0,
                    h: 0,
                },
                scale: 50,
                rayN: 512,
                rayWidth: 0.2,
                aperture: 0.8,
                lens: {
                    x: -64,
                    r: 26,
                    f: 50,
                    n: 1.5,
                },
                uiCircleR: 2.4,
                lensMoveSensitivity: 1,
                sensor: {
                    x: 0.0,
                    size: 24, // Height is 2*size
                },
                newLight: {
                    hue: 120
                },
                lights: [
                    { x: -22 * 12, y: -1 * 12, color: `hsl(0, 100%, 50%, ${lightAlpha})`, enabled: true },
                    { x: -28 * 12, y: -0.5 * 12, color: `hsl(120, 100%, 50%, ${lightAlpha})`, enabled: true },
                    { x: -20 * 12, y: 1 * 12, color: `hsl(240, 100%, 50%, ${lightAlpha})`, enabled: true },
                ],
                options: {
                    showAxes: true,
                    showAperture: true,
                    showApertureGuide: true,
                    showLens: true,
                    showBody: true,
                    showAngle: true,
                    showInfo: true,
                    useIdealLens: true,
                    renderOmissionWhileMoving: false,
                    randomRays: false,
                },
                fps: 0,
                moveHandler: null,
            }
        },
        computed: {
            effectiveLensRadius() {
                if (this.options.showAperture) {
                    return this.lens.r * this.aperture;
                } else {
                    return this.lens.r;
                }
            },
            fNumber() {
                return this.lens.f / (this.effectiveLensRadius * 2);
            },
            lensR() {
                const R = this.calcLensR(this.lens.n, this.lens.f, this.lens.r);
                if (R < 0) {
                    // Failed to solve R (no real answer?)
                    console.log("Failed to calculate lens R");
                    return this.lens.r * 1.01;
                }
                console.assert(R > this.lens.r);
                return R;
            },
            lensD() {
                return this.calcLensD(this.lens.r, this.lensR);
            },
            bodyWidth() {
                return this.sensor.x - this.lens.x + 2;
            },
            bodyHeight() {
                return Math.max(this.lens.r * 2, this.sensor.size + 0.8);
            },
            viewBoxStr() {
                return `${this.viewBox.x} ${this.viewBox.y} ${this.viewBox.w} ${this.viewBox.h}`;
            },
            maxR() {
                let maxR2 = this.viewBox.h * this.viewBox.h + this.viewBox.w * this.viewBox.w;
                this.lights.forEach((light) => {
                    const dx = Math.max(Math.abs(this.viewBox.x - light.x), Math.abs(this.viewBox.x + this.viewBox.w - light.x));
                    const dy = Math.max(Math.abs(this.viewBox.y - light.y), Math.abs(this.viewBox.y + this.viewBox.h - light.y));
                    maxR2 = Math.max(dx * dx + dy * dy, maxR2);
                });
                return Math.sqrt(maxR2) * 2;
                // TODO: Check if long enough (Use as length of infinity ray)
            },
            focalInfo() {
                const f = this.lens.f;
                const b = this.sensor.x - this.lens.x;
                const a = f * b / (b - f);

                const focalPosX = this.lens.x - a;
                const focalPosSize = this.sensor.size / 2 * (a / b);

                const [innerX, innerY] = this.extendSegment(this.lens.x, -this.effectiveLensRadius, focalPosX, -focalPosSize);
                const [outerX, outerY] = this.extendSegment(this.lens.x, -this.effectiveLensRadius, focalPosX, focalPosSize);

                return {
                    focalPos: { x: focalPosX, size: focalPosSize },
                    inner: { x: innerX, y: innerY },
                    outer: { x: outerX, y: outerY },
                }
            },
        },
        watch: {
            'lens.n'(newN, oldN) {
                if (this.calcLensR(newN, this.lens.f, this.lens.r) < 0) {
                    console.log(`Failed to calculate lens R from n = ${newN}`);
                    this.lens.n = oldN;
                }
            },
            'lens.r'(newR, oldR) {
                if (this.calcLensR(this.lens.n, this.lens.f, newR) < 0) {
                    console.log(`Failed to calculate lens R from r = ${newR}`);
                    this.lens.r = oldR;
                }
            }
        },
        methods: {
            calcLensN(f, d, r) {
                // These formulas are made from lens-maker's formula
                const R = r * r / d + d / 4;

                const a = f * (2 * R - d);
                const b = 2 * f * (d - R) - R * R;
                const c = - d * f;

                const cond = b * b - 4 * a * c;
                if (cond < 0) {
                    return NaN;
                }

                // TODO: What is negative answer?
                const n1 = (-b + Math.sqrt(cond)) / (2 * a);
                // const n2 = (-b - Math.sqrt(cond)) / (2 * a);
                return n1;
            },
            calcLensR(n, f, r) {
                // This formula is made from lens-maker's formula and d = 2(R-sqrt(R^2-r^2))
                const func = (R) => {
                    let res = 0;
                    res += n * n * Math.pow(R, 4);
                    res += - 4 * n * (n - 1) * f * Math.pow(R, 3);
                    res += 4 * (n - 1) * (n - 1) * f * f * (1 - (n - 1) * (n - 1)) * R * R;
                    res += 4 * Math.pow(n - 1, 4) * f * f * r * r;

                    return res;
                };

                // Derivative of func
                const funcc = (R) => {
                    let res = 0;
                    res += 4 * n * n * Math.pow(R, 3);
                    res += - 12 * n * (n - 1) * f * Math.pow(R, 2);
                    res += 8 * (n - 1) * (n - 1) * f * f * (1 - (n - 1) * (n - 1)) * R;
                    return res;
                };

                // Solve func(R) = 0 by Newton' method
                let R = 100 * n; // NOTICE: Very heuristic
                for (let i = 0; i < 100; i++) {
                    // console.log(R, func(R), funcc(R))
                    R = R - func(R) / funcc(R);

                    // Validation R with desired focal length
                    // Calculate focal length by lens maker's formula
                    const d = 2 * (R - Math.sqrt(R * R - r * r));
                    const desiredLensF = f;
                    const actualLensF = 1.0 / (2 * (n - 1) / R - (n - 1) * (n - 1) * d / (n * R * R));

                    const absError = Math.abs(desiredLensF - actualLensF);
                    const relError = absError / desiredLensF;
                    if (relError < 1e-8) {
                        return R;
                    }
                }

                // Failed
                return -1.0;
            },
            calcLensD(r, R) {
                return 2 * (R - Math.sqrt(R * R - r * r));
            },
            getMousePosition(e) {
                const rect = this.canvas.getBoundingClientRect()
                const xPix = e.clientX - rect.left;
                const yPix = e.clientY - rect.top;
                const x = xPix / this.scale + this.viewBox.x;
                const y = yPix / this.scale + this.viewBox.y;
                return [x, y];
            },
            lightMoveHandler(e, light) {
                const [sx, sy] = this.getMousePosition(e);
                const x = light.x;
                const y = light.y;

                const handler = (e) => {
                    const [tx, ty] = this.getMousePosition(e);
                    const nx = x + (tx - sx);
                    const ny = y + (ty - sy);
                    const maxX = this.lens.x - this.lens.f * 1.01;
                    light.x = maxX < nx ? maxX : nx;
                    light.y = ny;
                };

                this.moveHandler = handler;
            },
            lensMoveHandler(e) {
                const [sx, sy] = this.getMousePosition(e);
                const x = this.lens.x;
                const handler = (e) => {
                    const [tx, ty] = this.getMousePosition(e);
                    let nx = x + (tx - sx) / this.lensMoveSensitivity;
                    this.lights.forEach((light) => {
                        if (light.enabled) {
                            const minX = light.x + 1.01 * this.lens.f;
                            if (nx < minX) {
                                nx = minX;
                            }
                        }
                    });
                    if (nx > this.sensor.x) {
                        nx = this.sensor.x;
                    }
                    this.lens.x = nx;
                };

                this.moveHandler = handler;
            },
            focalLengthMoveHandler(e) {
                const [sx, sy] = this.getMousePosition(e);
                const x = this.lens.x - this.lens.f;
                const handler = (e) => {
                    const [tx, ty] = this.getMousePosition(e);
                    let nx = x + (tx - sx);
                    // Doesn't go left than light sources
                    this.lights.forEach((light) => {
                        if (light.enabled) {
                            const minX = light.x + 1;
                            if (nx < minX) {
                                nx = minX;
                            }
                        }
                    });
                    // Doesn't collision to lens
                    if (nx > this.lens.x - 1) {
                        nx = this.lens.x - 1;
                    }

                    const nLensF = this.lens.x - nx;
                    const nLensR = this.calcLensR(this.lens.n, nLensF, this.lens.r);
                    const nLensD = this.calcLensD(this.lens.r, nLensR)
                    if (nLensD < this.lens.r * minLensD) {
                        return;
                    }
                    if (nLensD > this.lens.r * maxLensD) {
                        return;
                    }
                    if (nLensD / 2 < nLensF) {
                        this.lens.f = nLensF;
                    }
                };

                this.moveHandler = handler;
            },
            lensSizeMoveHandler(e) {
                const [sx, sy] = this.getMousePosition(e);
                const y = -this.lens.r
                const handler = (e) => {
                    const [tx, ty] = this.getMousePosition(e);
                    let ny = y + (ty - sy);
                    if (ny > -1) {
                        ny = -1;
                    }
                    const nLensSize = -ny;
                    const nLensR = this.calcLensR(this.lens.n, this.lens.f, nLensSize);
                    if (0 < nLensR) {
                        const nLensD = this.calcLensD(nLensSize, nLensR);
                        if (nLensD < nLensSize * minLensD) {
                            return;
                        }
                        if (nLensD > nLensSize * maxLensD) {
                            return;
                        }
                        this.lens.r = nLensSize;
                    }
                };

                this.moveHandler = handler;
            },
            lensThicknessMoveHandler(e) {
                const [sx, sy] = this.getMousePosition(e);
                const x = this.lens.x - this.lensD / 2;
                const handler = (e) => {
                    const [tx, ty] = this.getMousePosition(e);
                    const nx = x + (tx - sx);
                    let nLensD = 2 * (this.lens.x - nx);

                    if (nLensD < this.lens.r * minLensD) {
                        nLensD = this.lens.r * minLensD;
                    }

                    // TODO: This bound is workaround.
                    if (nLensD >= this.lens.r * maxLensD) {
                        nLensD = this.lens.r * maxLensD;
                    }

                    const nLensN = this.calcLensN(this.lens.f, nLensD, this.lens.r);
                    if (!isNaN(nLensN) && nLensN > 0) {
                        this.lens.n = nLensN;
                    }
                };

                this.moveHandler = handler;
            },
            sensorSizeMoveHandler(e) {
                const [sx, sy] = this.getMousePosition(e);
                const y = -this.sensor.size / 2;

                const handler = (e) => {
                    const [tx, ty] = this.getMousePosition(e);
                    const ny = y + (ty - sy);
                    const maxY = -1;
                    this.sensor.size = maxY < ny ? -maxY * 2 : -ny * 2;
                };

                this.moveHandler = handler;
            },
            apertureMoveHandler(e) {
                const [sx, sy] = this.getMousePosition(e);
                const y = -this.effectiveLensRadius;

                const handler = (e) => {
                    const [tx, ty] = this.getMousePosition(e);
                    const ny = y + (ty - sy);
                    if (0 < ny) {
                        this.aperture = 0;
                    } else if (ny < -this.lens.r) {
                        this.aperture = 1;
                    } else {
                        this.aperture = -ny / this.lens.r;
                    }
                };

                this.moveHandler = handler;
            },
            mouseMove(e) {
                if (this.moveHandler) {
                    this.moveHandler(e);
                }
            },
            mouseUp(e) {
                this.moveHandler = null;
                this.moving = -1;
            },
            resize() {
                this.width = this.canvas.getBoundingClientRect().width;
                this.height = this.width * (5 / 10);
                this.canvas.width = this.width;
                this.canvas.height = this.height;
                this.sensorCanvas.width = this.sensorCanvas.getBoundingClientRect().width;
                this.sensorCanvas.height = this.height;
                this.sensorCanvas.style.width = this.sensorCanvas.getBoundingClientRect().width;
                this.sensorCanvas.style.height = this.canvas.getBoundingClientRect().height;
            },
            extendSegment(sx, sy, tx, ty) {
                const theta = Math.atan2(ty - sy, tx - sx);
                const ntx = sx + this.maxR * Math.cos(theta);
                const nty = sy + this.maxR * Math.sin(theta);
                return [ntx, nty];
            },
            humanReadable(v) {
                return v.toPrecision(3);
            },
            addLightSource(e, useMouse) {
                let x = (this.lens.x - this.lens.f + this.viewBox.x) / 2;
                let y = 0;
                if (useMouse) {
                    [x, y] = this.getMousePosition(e);
                }
                this.lights.push({
                    x: x,
                    y: y,
                    color: `hsl(${this.newLight.hue}, 100%, 50%, ${lightAlpha})`,
                    enabled: true,
                });
            },
            deleteLightSource(e, idx) {
                this.lights.splice(idx, 1);
                e.stopPropagation()
            },
        },
        mounted() {
            //================================
            // Support functions
            //================================
            const getIntersectionX = (px, py, theta, minX, maxX, y, maxR) => {
                const sin = Math.sin(theta);
                const cos = Math.cos(theta);
                const r = (y - py) / sin;
                const x = px + r * cos;
                if (r >= 0 && minX <= x && x <= maxX) {
                    return [true, x, y, r];
                } else {
                    return [false, px + maxR * cos, py + maxR * sin, maxR];
                }
            };

            const getIntersectionY = (px, py, theta, x, minY, maxY, maxR) => {
                const sin = Math.sin(theta);
                const cos = Math.cos(theta);
                const r = (x - px) / cos;
                const y = py + r * sin;
                if (r >= 0 && minY <= y && y <= maxY) {
                    return [true, x, y, r];
                } else {
                    return [false, px + maxR * cos, py + maxR * sin, maxR];
                }
            };

            const getIntersectionLens = (x, y, theta, cx, cy, r, R, maxR, select) => {
                const a = 1;
                const b = 2 * ((x - cx) * Math.cos(theta) + (y - cy) * Math.sin(theta));
                const c = Math.pow(x - cx, 2) + Math.pow(y - cy, 2) - R * R;
                const cond = b * b - 4 * a * c;
                if (cond < 0) {
                    return [false, x + maxR * Math.cos(theta), y + maxR * Math.sin(theta), maxR];
                }
                // NOTICE: Use smaller r
                const d1 = (-b - Math.sqrt(cond)) / (2 * a);
                const d2 = (-b + Math.sqrt(cond)) / (2 * a);
                const d = select ? d1 : d2;
                const tx = x + d * Math.cos(theta);
                const ty = y + d * Math.sin(theta);
                if (Math.abs(ty) > r) {
                    return [false, x + maxR * Math.cos(theta), y + maxR * Math.sin(theta), maxR];
                } else {
                    return [true, tx, ty, d];
                }
            };

            const dotAngle = (x1, y1, x2, y2) => {
                const norm1 = Math.sqrt(x1 * x1 + y1 * y1);
                const norm2 = Math.sqrt(x2 * x2 + y2 * y2);
                return Math.acos((x1 * x2 + y1 * y2) / (norm1 * norm2));
            };

            const crossAngle = (x1, y1, x2, y2) => {
                const norm1 = Math.sqrt(x1 * x1 + y1 * y1);
                const norm2 = Math.sqrt(x2 * x2 + y2 * y2);
                return Math.asin((x1 * y2 - x2 * y1) / (norm1 * norm2));
            };

            const getIntersectionBody = (cx, cy, theta, maxR, isInner) => {
                // Front
                if (!isInner) {
                    const [hit0, x0, y0, r0] = getIntersectionY(cx, cy, theta, this.lens.x, -this.bodyHeight / 2, this.bodyHeight / 2, maxR);
                    if (hit0 && r0 > 0) {
                        // NOTICE: Assume all rays passes left to right
                        // r0 > 0 condition is for inner rays.
                        return [hit0, x0, y0, r0];
                    }
                }
                // Top
                const [hit1, x1, y1, r1] = getIntersectionX(cx, cy, theta, this.lens.x, this.lens.x + this.bodyWidth, -this.bodyHeight / 2, maxR);
                if (hit1 && isInner) {
                    return [hit1, x1, y1, r1];
                }
                // Bottom
                const [hit2, x2, y2, r2] = getIntersectionX(cx, cy, theta, this.lens.x, this.lens.x + this.bodyWidth, this.bodyHeight / 2, maxR);
                if (hit2 && isInner) {
                    return [hit2, x2, y2, r2];
                }

                if (!isInner) {
                    if (r1 < r2) {
                        return [hit1, x1, y1, r1];
                    } else {
                        return [hit2, x2, y2, r2];
                    }
                }

                // Behind the sensor
                const [hit3, x3, y3, r3] = getIntersectionY(cx, cy, theta, this.lens.x + this.bodyWidth, -this.bodyHeight / 2, this.bodyHeight / 2, maxR);
                if (hit3) {
                    return [hit3, x3, y3, r3];
                }

                // Return closest intersection
                if (r1 <= r2 && r1 <= r3) {
                    return [hit1, x1, y1, r1];
                } else if ((r2 <= r1 && r2 <= r3)) {
                    return [hit2, x2, y2, r2];
                } else {
                    return [hit3, x3, y3, r3];
                }
            };

            const drawSegment = (ctx, sx, sy, tx, ty) => {
                ctx.beginPath();
                ctx.moveTo(sx, sy);
                ctx.lineTo(tx, ty);
                ctx.stroke();
            };

            //================================
            // Canvas setup
            //================================
            // Main canvas
            this.canvas = document.getElementById("canvas");

            // Sensor canvas
            this.sensorCanvas = document.getElementById("canvas-sensor");
            const sensorCanvasCtx = this.sensorCanvas.getContext("2d");

            this.resize();
            window.addEventListener("resize", this.resize);

            // Prepare offscreen canvas
            const offscreen = new OffscreenCanvas(this.canvas.width, this.canvas.height);
            const ctx = offscreen.getContext("2d", { alpha: false });
            const mainCtx = this.canvas.getContext("bitmaprenderer");

            // Define scale factor
            this.scale = this.canvas.height / (this.sensor.size * 8);

            //================================
            // Render callback function
            //================================
            let frames = 0;
            let startTime = new Date().getTime();
            const render = () => {
                // Calculate FPS
                frames += 1;
                let endTime = new Date().getTime();
                if (endTime - startTime >= 1000) {
                    this.fps = frames / (endTime - startTime) * 1000;
                    startTime = endTime;
                    frames = 0;
                }

                //================================
                // Main canvas drawing
                //================================
                const w = this.canvas.width;
                const h = this.canvas.height;

                this.viewBox.w = w / this.scale;
                this.viewBox.h = h / this.scale;
                this.viewBox.x = -0.95 * this.viewBox.w
                this.viewBox.y = -this.viewBox.h / 2;

                offscreen.width = w;
                offscreen.height = h;

                //--------------------------------
                // Clear canvas
                //--------------------------------
                ctx.reset();
                ctx.transform(this.scale, 0, 0, this.scale, -this.viewBox.x * this.scale, -this.viewBox.y * this.scale);
                ctx.fillRect(this.viewBox.x, this.viewBox.y, this.viewBox.w, this.viewBox.h); // background
                ctx.globalCompositeOperation = 'lighten';

                //--------------------------------
                // Rays
                //--------------------------------
                let sensorIntersections = new Array(this.lights.length).fill([]);
                this.lights.forEach((light, idx) => {
                    if (!light.enabled) {
                        return;
                    }

                    const x = light.x;
                    const y = light.y;
                    const color = light.color;
                    ctx.strokeStyle = color;

                    // Find a range that needs intersection calculation
                    const thetaMin = Math.min(
                        Math.atan2(-this.bodyHeight / 2 - y, this.lens.x - x),// top left
                        Math.atan2(-this.bodyHeight / 2 - y, this.lens.x + (this.options.showBody ? this.bodyWidth : 0) - x) // top right
                    );
                    const thetaMax = Math.max(
                        Math.atan2(this.bodyHeight / 2 - y, this.lens.x - x), // bottom left
                        Math.atan2(this.bodyHeight / 2 - y, this.lens.x + (this.options.showBody ? this.bodyWidth : 0) - x) // bottom right
                    );


                    // Find image position (ux, uy) of the light source
                    const s1 = this.lens.x - light.x;
                    const s2 = this.lens.f * s1 / (s1 - this.lens.f);
                    const ux = s2;
                    const uy = -light.y * (s2 / s1)

                    // Draw rays
                    let sensorIntersectionsForLight = [];
                    ctx.lineWidth = this.rayWidth;
                    const itr = this.options.renderOmissionWhileMoving && this.moveHandler ? Math.min(512, this.rayN) : this.rayN;
                    for (let i = 0; i < itr; i++) {
                        // Draw outer ray
                        const theta = this.options.randomRays
                            ? 2 * Math.PI * Math.random() - Math.PI
                            : 2 * Math.PI * i / itr - Math.PI; // -pi <= theta < pi

                        let innerStartX, innerStartY, innerPhi;

                        if (!this.options.showLens) {
                            //--------------------------------
                            // Pinhole lens
                            //--------------------------------
                            // Pruning intersection check of left oriented rays for optimization
                            if (theta < thetaMin || thetaMax < theta) {
                                // Draw light source to infinity ray
                                drawSegment(ctx, x, y, x + this.maxR * Math.cos(theta), y + this.maxR * Math.sin(theta));
                                continue;
                            }

                            // Check intersection with lens
                            const [hitLens, tx, ty] = getIntersectionY(x, y, theta, this.lens.x, -this.lens.r, this.lens.r, this.maxR);

                            if (!hitLens && this.options.showBody) {
                                // Draw rays don't enter into the lens
                                const [hitBody, tx, ty] = getIntersectionBody(x, y, theta, this.maxR, false);
                                drawSegment(ctx, x, y, tx, ty);
                                continue;
                            }

                            // Draw light to lens ray
                            drawSegment(ctx, x, y, tx, ty);

                            // Just through the pinhole
                            innerPhi = theta;

                            innerStartX = tx;
                            innerStartY = ty;
                        } else if (-Math.PI / 2 < theta && theta < Math.PI / 2 && !this.options.useIdealLens) {
                            //--------------------------------
                            // Actual lens
                            //--------------------------------
                            // Collision to the left side of the lens
                            const cx = this.lens.x + this.lensR - this.lensD / 2;
                            const cy = 0;
                            const [hit, tx, ty, r] = getIntersectionLens(x, y, theta, cx, cy, this.lens.r, this.lensR, this.maxR, true);

                            // Collision to the body
                            const [hitBody, txBody, tyBody, rBody] = getIntersectionBody(x, y, theta, this.maxR, false);

                            if (this.options.showBody && rBody < r) {
                                // Draw light source to the body ray
                                drawSegment(ctx, x, y, txBody, tyBody);
                                continue;
                            }
                            // Draw light source to the lens surface ray
                            drawSegment(ctx, x, y, tx, ty);

                            // Draw inner-lens rays
                            if (hit) {
                                const phi1 = crossAngle(tx - cx, ty - cy, -(tx - x), -(ty - y));
                                const phi2 = Math.asin(Math.sin(phi1) / this.lens.n);
                                const phi3 = Math.atan2(ty - cy, tx - cx) + Math.PI + phi2;

                                // Aperture collision
                                {
                                    const [hitLensCenter, dummyX, dummyY] = getIntersectionY(tx, ty, phi3, this.lens.x, -this.effectiveLensRadius, this.effectiveLensRadius, this.maxR);
                                    const [hitBodyFront, wx, wy] = getIntersectionY(tx, ty, phi3, this.lens.x, -this.bodyHeight / 2, this.bodyHeight / 2, this.maxR);
                                    if (!hitLensCenter) {
                                        drawSegment(ctx, tx, ty, wx, wy);
                                        continue;
                                    }
                                }

                                // Right side of lens
                                const cx2 = this.lens.x - (this.lensR - this.lensD / 2);
                                const cy2 = 0;
                                const [hit, wx, wy] = getIntersectionLens(tx, ty, phi3, cx2, cy2, this.lens.r, this.lensR, this.maxR, false);

                                if (hit) {
                                    drawSegment(ctx, tx, ty, wx, wy);
                                    const phi1 = crossAngle(wx - cx2, wy - cy2, wx - tx, wy - ty);
                                    const phi2 = Math.asin(Math.sin(phi1) * this.lens.n);
                                    const phi3 = Math.atan2(wy - cy2, wx - cx2) + phi2;
                                    innerStartX = wx;
                                    innerStartY = wy;
                                    innerPhi = phi3;

                                    // Total reflection
                                    if (isNaN(phi3)) {
                                        continue;
                                    }
                                }
                            }
                        } else {
                            //--------------------------------
                            // Ideal lens
                            //--------------------------------
                            // Pruning intersection check of left oriented rays for optimization
                            if (theta < thetaMin || thetaMax < theta) {
                                // Draw light source to infinity ray
                                drawSegment(ctx, x, y, x + this.maxR * Math.cos(theta), y + this.maxR * Math.sin(theta));
                                continue;
                            }

                            // Check intersection with lens
                            const [hitLens, tx, ty] = getIntersectionY(x, y, theta, this.lens.x, -this.lens.r, this.lens.r, this.maxR);

                            if (!hitLens && this.options.showBody) {
                                // Draw rays don't enter into the lens
                                const [hitBody, tx, ty] = getIntersectionBody(x, y, theta, this.maxR, false);
                                drawSegment(ctx, x, y, tx, ty);
                                continue;
                            }

                            // Draw light to lens ray
                            drawSegment(ctx, x, y, tx, ty);

                            // Calculate refraction direction (phi)
                            innerPhi = Math.atan2(uy - ty, ux);

                            innerStartX = tx;
                            innerStartY = ty;
                        }

                        const tx = innerStartX;
                        const ty = innerStartY;
                        const phi = innerPhi;

                        // Draw inner ray
                        const notHitAperture = -this.effectiveLensRadius < ty && ty < this.effectiveLensRadius
                        if (notHitAperture || !this.options.useIdealLens) {

                            if (!this.options.showBody) {
                                drawSegment(ctx, tx, ty, tx + this.maxR * Math.cos(phi), ty + this.maxR * Math.sin(phi));
                                continue;
                            }

                            // Check intersection to the sensor
                            const [hitSensor, vx, vy] = getIntersectionY(tx, ty, phi, this.sensor.x, -this.sensor.size / 2, this.sensor.size / 2, this.maxR, false);

                            // Draw lens to sensor ray
                            if (hitSensor) {
                                drawSegment(ctx, tx, ty, vx, vy);
                            } else {
                                const [hitBody, vx, vy] = getIntersectionBody(tx, ty, phi, this.maxR, true);
                                console.assert(hitBody); // Inner rays should always hit to the box
                                drawSegment(ctx, tx, ty, vx, vy);
                            }

                            // Record intersection
                            if (hitSensor && this.options.showBody) {
                                sensorIntersectionsForLight.push(vy);
                                continue;
                            }
                        }
                    }
                    sensorIntersections[idx] = sensorIntersectionsForLight;
                });

                //--------------------------------
                // Copy offscreen render result to main canvas
                //--------------------------------
                mainCtx.transferFromImageBitmap(offscreen.transferToImageBitmap());

                //================================
                // Sensor canvas drawing
                //================================
                sensorCanvasCtx.reset();
                sensorCanvasCtx.fillRect(0, 0, this.sensorCanvas.width, this.sensorCanvas.height); // background
                const sensorCanvasScale = this.sensorCanvas.height / (this.sensor.size);
                sensorCanvasCtx.transform((1 << 6) / this.rayWidth, 0, 0, sensorCanvasScale, this.sensorCanvas.width / 2, this.sensorCanvas.height / 2);
                sensorCanvasCtx.globalCompositeOperation = 'lighten';

                sensorIntersections.forEach((sensorIntersectionsForLight, idx) => {
                    const color = this.lights[idx].color;
                    sensorCanvasCtx.fillStyle = color;
                    sensorIntersectionsForLight.forEach((y) => {
                        sensorCanvasCtx.beginPath();
                        sensorCanvasCtx.arc(0, y, this.rayWidth / 2, 0, Math.PI * 2);
                        sensorCanvasCtx.fill();
                    });
                });
            }

            // Render only when data changed or window resized
            this.$watch('$data', () => {
                requestAnimationFrame(render);
            }, { deep: true, immediate: true });
            window.addEventListener("resize", render);
        },
    }).mount('#app')
</script>