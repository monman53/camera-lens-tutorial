<meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-E9ZG1KHTVT"></script>
<script src='/scripts/google.js'></script>

<style>
    .container {
        display: grid;
        grid-template-columns: 9fr 1fr;
        gap: 10px;
    }

    .item-main {
        grid-column: 1;
        grid-row: 1;
    }

    .item-sensor {
        grid-column: 2;
        grid-row: 1;
    }

    #stage {
        position: relative;
        display: inline;
    }

    #canvas {
        width: 100%;
        position: absolute;
        z-index: 1;
    }

    #ui {
        position: absolute;
        z-index: 2;
    }

    #canvas-sensor {
        width: 100%;
    }

    svg {
        fill: none;
    }

    .svg-axis {
        stroke-width: 0.01;
        stroke: white;
    }

    .svg-light-source,
    .svg-sensor,
    .svg-line {
        stroke-width: 0.03;
        stroke: white;
    }

    .svg-lens,
    .svg-sensor-size {
        fill: white;
        fill-opacity: 0.0;
    }

    .svg-focal-point {
        fill: white;
    }

    .svg-sensor-size:hover,
    .svg-lens:hover {
        stroke-width: 0.03;
        stroke: white;
    }
</style>

<title>Simple Camera Lens Simulator</title>

<div id="app">
    <div class="container">
        <div class="item-main" id="stage">
            <canvas id="canvas"></canvas>
            <svg id="ui" :width="width" :height="height" :view-box.camel="viewBoxStr" xmlns="http://www.w3.org/2000/svg"
                @mousemove="mouseMove" @mouseup="mouseUp">
                <!-- Axes -->
                <line class="svg-axis" :x1="viewBox.x" y1="0" :x2="viewBox.x+viewBox.w" y2="0" />
                <line class="svg-axis" x1="0" :y1="-viewBox.y" x2="0" :y2="viewBox.y" />
                <!-- Box -->
                <line class="svg-line" :x1="lens.x" :y1="-boxHeight/2" :x2="lens.x+boxWidth" :y2="-boxHeight/2" />
                <line class="svg-line" :x1="lens.x" :y1="boxHeight/2" :x2="lens.x+boxWidth" :y2="boxHeight/2" />
                <line class="svg-line" :x1="lens.x+boxWidth" :y1="-boxHeight/2" :x2="lens.x+boxWidth"
                    :y2="boxHeight/2" />
                <line class="svg-line" :x1="lens.x" :y1="-boxHeight/2" :x2="lens.x" :y2="-lensSize" />
                <line class="svg-line" :x1="lens.x" :y1="lensSize" :x2="lens.x" :y2="boxHeight/2" />
                <!-- Light sources position -->
                <g v-for="light in lights">
                    <circle class="svg-light-source" v-if="light.enabled" :cx="light.x" :cy="light.y" r="0.2"
                        :fill="light.color" @mousedown="lightMoveHandler($event, light)" />
                </g>
                <!-- Lens position -->
                <rect class="svg-lens" :x="lens.x-0.2" :y="-lensSize" :width="0.4" :height="2*lensSize"
                    @mousedown="lensMoveHandler" />
                <!-- Sensor -->
                <line class="svg-sensor" :x1="sensor.x" :y1="-sensor.size" :x2="sensor.x" :y2="sensor.size" />
                <circle class="svg-sensor-size" :cx="sensor.x" :cy="-sensor.size" r="0.2"
                    @mousedown="sensorSizeMoveHandler" />
                <!-- Focal point -->
                <circle class="svg-focal-point" :cx="lens.x-focalLength" :cy="0" r="0.05" />
                <circle class="svg-focal-point" :cx="lens.x+focalLength" :cy="0" r="0.05" />
            </svg>
        </div>
        <div class="item-sensor">
            <canvas id="canvas-sensor"></canvas>
        </div>
    </div>

    <div>
        <label>
            Aperture
            <input type="range" min="0" :max="1" step="0.001" v-model.number="aperture">
            {{aperture}}
        </label>
        <br>
        <!-- <label>
            Sensor size
            <input type="range" min="0.1" :max="3" step="0.01" v-model.number="sensor.size">
            {{sensor.size}}
        </label>
        <br>
        <label>
            Sensor position
            <input type="range" :min="lens.x+focalLength*0.99" max="8" step="0.001" v-model.number="sensor.x">
            {{sensor.x}}
        </label>
        <br> -->
        <!-- <label>
            Lens position
            <input type="range" min="-1" max="1" step="0.0001" v-model.number="lens.x">
            {{lens.x}}
        </label> -->
        <!-- <br> -->
        <label>
            Lens thickness
            <input type="range" min="0.1" :max="Math.min(5, lens.r*2)" step="0.1" v-model.number="lens.d">
            {{lens.d}}
        </label>
        <br>
        <label>
            Lens R
            <input type="range" :min="lens.d/2" max="100" step="0.1" v-model.number="lens.r">
            {{lens.r}}
        </label>
        <br>
        <label>
            Number of rays
            <input type="range" min="1" max="4096" step="1" v-model.number="rayN">
            {{rayN}}
        </label>
        <br>
        <label>
            Ray width
            <input type="range" min="0.01" max="1.0" step="0.01" v-model.number="rayWidth">
            {{rayWidth}}
        </label>
        <br>
        <label>
            Canvas scale
            <input type="range" min="0.1" max="100" step="0.1" v-model.number="scale">
            {{scale}}
        </label>
        <br>
        <label v-for="light in lights">
            <input type="checkbox" v-model="light.enabled">
            Show light {{light.color}}
            <br>
        </label>
    </div>

    <div>
        <h2>Description</h2>
        <p>This is an interactive tool for understanding how the camera works. You can change some conditions and see
            how camera effects change by viewing rays path and image on virtual 1D image sensor.</p>
        <h3>Usage</h3>
        <ul>
            <li>Move the light sources by mouse drag and see how the rays path change.</li>
        </ul>
        <h3>List of controllable places</h3>
        <ul>
            <li>Aperture</li>
            <li>Lens position (x-axis)</li>
            <li>Lens curvature (changes focal length)</li>
            <li>Lens thickness (does't change focal length)</li>
            <li>Image sensor size</li>
            <li>Image sensor position (x-axis)</li>
            <li>Number of rays from light source (affects performance significantly)</li>
            <li>Rays intensity (ray boldness)</li>
            <li>Light source selection (up to 3)</li>
        </ul>
        <h3>List of the major questions about camera that this tool supports to understand.</h3>
        <ul>
            <li>Q. What is the bokeh (blur effect)?</li>
            <ul>
                <li>A. A not focused circle-shape image. See how focus works by changing lens position.</li>
            </ul>
            <li>Q. How the aperture effects to the bokeh?</li>
            <ul>
                <li>A. Puts multiple light sources with difference distances and see how the size of image changes on
                    virtual image sensor by changing aperture value.</li>
            </ul>
            <li>Q. Why the angle of view changes between different size of image sensors?</li>
            <ul>
                <li>A. See how the image on virtual sensor by changing the sensor size.</li>
            </ul>
            <!-- <li>Q. Why vignetting occurs when using lenses for smaller image sensor?</li>
            <ul>
                <li>A. Lenses for the smaller image sensor (e.g. micro-four-thirds) uses smaller diameter of lenses but
                    same focal length. Put a light source that makes image on the around of corner of image sensor and
                    change lens thickness to see how image cropped (vignetting).
                </li>
            </ul> -->
        </ul>
        <h2>Features</h2>
        <ul>
            <li>Mouse interactive</li>
            <li>Real-time rendering</li>
            <li>Single HTML app (Internet access is needed)</li>
            <!-- <li>Mobile friendly (maybe)</li> -->
        </ul>
        <!-- <h2>Q&A</h2>
        <ul>
            <li>
                Q. xxx.
                <ul>
                    <li>A. xxx.
                    </li>
                </ul>
            </li>
        </ul> -->
        <h2>Used technologies</h2>
        <ul>
            <li>HTML / Javascript</li>
            <li>Vue.js 3</li>
            <li>Canvas API</li>
        </ul>
        <p>
            <a href="https://github.com/monman53/simple-camera-simulator">Source codes (GitHub)</a>
            Any suggestions and issues are welcome.
        </p>
        <h2>Future works</h2>
        <ul>
            <li>Support shutter</li>
            <li>More detail emulation for lens refraction</li>
            <li>Support composite lenses</li>
        </ul>
        <h2>References</h2>
        <ul>
            <li><a href="https://en.wikipedia.org/wiki/Lens">Lens - Wikipedia</a></li>
        </ul>
        <h2>Contacts</h2>
        <ul>
            <li><a href="https://github.com/monman53/simple-camera-lens-simulator">GitHub (This project)</a></li>
            <li><a href="https://github.com/monman53">GitHub (Profile page)</a></li>
            <li><a href="https://twitter.com/monman53">Twitter</a></li>
        </ul>
    </div>
</div>

<script type="module">
    import { createApp } from 'https://unpkg.com/vue@3/dist/vue.esm-browser.js'
    // import { createApp } from 'https://unpkg.com/vue@3/dist/vue.esm-browser.prod.js'

    createApp({
        data() {
            return {
                canvas: undefined,
                sensorCanvas: undefined,
                width: 1600,
                height: 800,
                viewBox: {
                    x: 0,
                    y: 0,
                    w: 0,
                    h: 0,
                },
                scale: 50,
                rayN: 256,
                rayWidth: 0.4,
                lens: {
                    x: -4.0,
                    r: 10.0,
                    d: 0.3,
                    n: 1.5,
                },
                sensor: {
                    x: 0.0,
                    size: 1.0,
                },
                aperture: 1.0,
                lights: [
                    { x: -9, y: -1, color: "rgba(255, 0, 0, 0.8)", enabled: true },
                    { x: -12, y: -0.5, color: "rgba(0, 255, 0, 0.8)", enabled: true },
                    { x: -20, y: 1, color: "rgba(0, 0, 255, 0.8)", enabled: true },
                ],
                fps: 0,
                moveHandler: null,
            }
        },
        methods: {
            getMousePosition(e) {
                const rect = this.canvas.getBoundingClientRect()
                const xPix = e.clientX - rect.left;
                const yPix = e.clientY - rect.top;
                const x = xPix / this.scale + this.viewBox.x;
                const y = yPix / this.scale + this.viewBox.y;
                return [x, y];
            },
            lightMoveHandler(e, light) {
                const [sx, sy] = this.getMousePosition(e);
                const x = light.x;
                const y = light.y;

                const handler = (e) => {
                    const [tx, ty] = this.getMousePosition(e);
                    const nx = x + (tx - sx);
                    const ny = y + (ty - sy);
                    const maxX = this.lens.x - this.focalLength * 1.01;
                    light.x = maxX < nx ? maxX : nx;
                    light.y = ny;
                };

                this.moveHandler = handler;
            },
            lensMoveHandler(e) {
                const [sx, sy] = this.getMousePosition(e);
                const x = this.lens.x;
                const handler = (e) => {
                    const [tx, ty] = this.getMousePosition(e);
                    let nx = x + (tx - sx);
                    this.lights.forEach((light) => {
                        if (light.enabled) {
                            const minX = light.x + 1.01 * this.focalLength;
                            if (nx < minX) {
                                nx = minX;
                            }
                        }
                    });
                    if (nx > this.sensor.x) {
                        nx = this.sensor.x;
                    }
                    this.lens.x = nx;
                };

                this.moveHandler = handler;
            },
            sensorSizeMoveHandler(e) {
                const [sx, sy] = this.getMousePosition(e);
                const y = -this.sensor.size;

                const handler = (e) => {
                    const [tx, ty] = this.getMousePosition(e);
                    const ny = y + (ty - sy);
                    const maxY = -0.1;
                    this.sensor.size = maxY < ny ? -maxY : -ny;
                };

                this.moveHandler = handler;
            },
            mouseMove(e) {
                if (this.moveHandler) {
                    this.moveHandler(e);
                }
            },
            mouseUp(e) {
                this.moveHandler = null;
                this.moving = -1;
            },
            resize() {
                this.width = this.canvas.getBoundingClientRect().width;
                this.height = this.width * (5 / 10);
                this.canvas.width = this.width;
                this.canvas.height = this.height;
                this.sensorCanvas.width = this.sensorCanvas.getBoundingClientRect().width;
                this.sensorCanvas.height = this.height;
                this.sensorCanvas.style.width = this.sensorCanvas.getBoundingClientRect().width;
                this.sensorCanvas.style.height = this.canvas.getBoundingClientRect().height;
            },
        },
        computed: {
            focalLength() {
                return this.lens.r / 2 * (this.lens.n - 1);
            },
            lensSize() {
                const theta = Math.acos((this.lens.r - this.lens.d / 2) / this.lens.r);
                return this.lens.r * Math.sin(theta);
            },
            boxWidth() {
                return this.sensor.x - this.lens.x + 0.3;
            },
            boxHeight() {
                return Math.max(this.lensSize * 2, this.sensor.size * 2 + 0.8);
            },
            viewBoxStr() {
                return `${this.viewBox.x} ${this.viewBox.y} ${this.viewBox.w} ${this.viewBox.h}`;
            },
            maxR() {
                let maxR2 = 0;
                this.lights.forEach((light) => {
                    const dx = Math.max(Math.abs(this.viewBox.x - light.x), Math.abs(this.viewBox.x + this.viewBox.w - light.x));
                    const dy = Math.max(Math.abs(this.viewBox.y - light.y), Math.abs(this.viewBox.y + this.viewBox.h - light.y));
                    maxR2 = Math.max(dx * dx + dy * dy, maxR2);
                });
                return Math.sqrt(maxR2);
                // TODO: Check if long enough (Use as length of infinity ray)
            },
        },
        mounted() {
            //================================
            // Support functions
            //================================
            const getIntersectionX = (px, py, theta, minX, maxX, y, maxR) => {
                const sin = Math.sin(theta);
                const cos = Math.cos(theta);
                const r = (y - py) / sin;
                const x = px + r * cos;
                if (r >= 0 && minX <= x && x <= maxX) {
                    return [true, x, y, r];
                } else {
                    return [false, px + maxR * cos, py + maxR * sin, maxR];
                }
            }

            const getIntersectionY = (px, py, theta, x, minY, maxY, maxR) => {
                const sin = Math.sin(theta);
                const cos = Math.cos(theta);
                const r = (x - px) / Math.cos(theta);
                const y = py + r * Math.sin(theta);
                if (r >= 0 && minY <= y && y <= maxY) {
                    return [true, x, y, r];
                } else {
                    return [false, px + maxR * cos, py + maxR * sin, maxR];
                }
            }

            const getIntersectionBox = (cx, cy, theta, maxR, skipBehindSensor, immediate) => {
                // Front
                const [hit0, x0, y0, r0] = getIntersectionY(cx, cy, theta, this.lens.x, -this.boxHeight / 2, this.boxHeight / 2, maxR);
                if (hit0 && r0 > 0) {
                    // NOTICE: Assume all rays passes left to right
                    // r0 > 0 condition is for inner rays.
                    return [hit0, x0, y0, r0];
                }
                // Top
                const [hit1, x1, y1, r1] = getIntersectionX(cx, cy, theta, this.lens.x, this.lens.x + this.boxWidth, -this.boxHeight / 2, maxR);
                if (hit1 && immediate) {
                    return [hit1, x1, y1, r1];
                }
                // Bottom
                const [hit2, x2, y2, r2] = getIntersectionX(cx, cy, theta, this.lens.x, this.lens.x + this.boxWidth, this.boxHeight / 2, maxR);
                if (hit2 && immediate) {
                    return [hit2, x2, y2, r2];
                }

                if (skipBehindSensor) {
                    if (r1 < r2) {
                        return [hit1, x1, y1];
                    } else {
                        return [hit2, x2, y2];
                    }
                }

                // Behind the sensor
                const [hit3, x3, y3, r3] = getIntersectionY(cx, cy, theta, this.lens.x + this.boxWidth, -this.boxHeight / 2, this.boxHeight / 2, maxR);
                if (hit3 && immediate) {
                    return [hit3, x3, y3, r3];
                }

                // Return closest intersection
                if (r1 <= r2 && r1 <= r3) {
                    return [hit1, x1, y1];
                } else if ((r2 <= r1 && r2 <= r3)) {
                    return [hit2, x2, y2];
                } else {
                    return [hit3, x3, y3];
                }
            }

            //================================
            // Canvas setup
            //================================
            // Main canvas
            this.canvas = document.getElementById("canvas");

            // Sensor canvas
            this.sensorCanvas = document.getElementById("canvas-sensor");
            const sensorCanvasCtx = this.sensorCanvas.getContext("2d");

            this.resize();
            window.addEventListener("resize", this.resize);

            // Prepare offscreen canvas
            const offscreen = new OffscreenCanvas(this.canvas.width, this.canvas.height);
            const ctx = offscreen.getContext("2d", { alpha: false });
            const mainCtx = this.canvas.getContext("bitmaprenderer");

            // Define scale factor
            this.scale = this.canvas.height / (this.sensor.size * 16);

            //================================
            // Render callback function
            //================================
            let frames = 0;
            let startTime = new Date().getTime();
            const render = () => {
                // Calculate FPS
                frames += 1;
                let endTime = new Date().getTime();
                if (endTime - startTime >= 1000) {
                    this.fps = frames / (endTime - startTime) * 1000;
                    startTime = endTime;
                    frames = 0;
                }

                //================================
                // Main canvas drawing
                //================================
                const w = this.canvas.width;
                const h = this.canvas.height;

                this.viewBox.w = w / this.scale;
                this.viewBox.h = h / this.scale;
                this.viewBox.x = -0.95 * this.viewBox.w
                this.viewBox.y = -this.viewBox.h / 2;

                offscreen.width = w;
                offscreen.height = h;

                //--------------------------------
                // Clear canvas
                //--------------------------------
                ctx.reset();
                ctx.transform(this.scale, 0, 0, this.scale, -this.viewBox.x * this.scale, -this.viewBox.y * this.scale);
                ctx.fillRect(this.viewBox.x, this.viewBox.y, this.viewBox.w, this.viewBox.h); // background
                ctx.globalCompositeOperation = 'lighten';

                //--------------------------------
                // Rays
                //--------------------------------
                let sensorIntersections = new Array(this.lights.length).fill([]);
                this.lights.forEach((light, idx) => {
                    if (!light.enabled) {
                        return;
                    }

                    const x = light.x;
                    const y = light.y;
                    const color = light.color;
                    ctx.strokeStyle = color;

                    let sensorIntersectionsForLight = [];
                    ctx.lineWidth = this.rayWidth / this.scale;
                    for (let i = 0; i < this.rayN; i++) {
                        // Draw outer ray
                        const theta = 2 * Math.PI * i / this.rayN;

                        // Pruning intersection check of left oriented rays for optimization
                        if (Math.PI / 2 <= theta && theta <= Math.PI * 3 / 2) {
                            // Draw light source to infinity ray
                            ctx.beginPath();
                            ctx.moveTo(x, y);
                            ctx.lineTo(x + this.maxR * Math.cos(theta), y + this.maxR * Math.sin(theta));
                            ctx.stroke();
                            continue;
                        }

                        // Check intersection with lens
                        const [hitLens, tx, ty] = getIntersectionY(x, y, theta, this.lens.x, -this.lensSize, this.lensSize, this.maxR);

                        if (!hitLens) {
                            // Draw light to box ray
                            const [hitBox, tx, ty] = getIntersectionBox(x, y, theta, this.maxR, true);
                            ctx.beginPath();
                            ctx.moveTo(x, y);
                            ctx.lineTo(tx, ty);
                            ctx.stroke();
                            continue;
                        }

                        // Draw light to lens ray
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(tx, ty);
                        ctx.stroke();

                        // Draw inner ray
                        const notHitAperture = -this.lensSize * this.aperture < ty && ty < this.lensSize * this.aperture;
                        if (notHitAperture) {
                            // Calculate refraction direction (phi)
                            const s1 = this.lens.x - light.x;
                            const s2 = this.focalLength * s1 / (s1 - this.focalLength);
                            const ux = s2;
                            const uy = -light.y * (s2 / s1)
                            const phi = Math.atan2(uy - ty, ux);

                            // Check intersection to the sensor
                            const [hitSensor, vx, vy] = getIntersectionY(tx, ty, phi, this.sensor.x, -this.sensor.size, this.sensor.size, this.maxR, false);

                            // Draw lens to sensor ray
                            if (hitSensor) {
                                ctx.beginPath();
                                ctx.moveTo(tx, ty);
                                ctx.lineTo(vx, vy);
                                ctx.stroke();
                            } else {
                                const [hitBox, vx, vy] = getIntersectionBox(tx, ty, phi, this.maxR);
                                console.assert(hitBox); // Inner rays should always hit to the box
                                ctx.beginPath();
                                ctx.moveTo(tx, ty);
                                ctx.lineTo(vx, vy);
                                ctx.stroke();
                            }

                            // Record intersection
                            if (hitSensor) {
                                sensorIntersectionsForLight.push(vy);
                                continue;
                            }
                        }
                    }
                    sensorIntersections[idx] = sensorIntersectionsForLight;
                });

                //--------------------------------
                // Camera components
                //--------------------------------
                ctx.lineWidth = 1 / this.scale;
                ctx.strokeStyle = "white";
                ctx.fillStyle = "white";

                //--------------------------------
                // Lens
                //--------------------------------
                {
                    const r = this.lens.r;
                    const d = this.lens.d;
                    const theta = Math.acos((r - d / 2) / r);
                    const y = 0;
                    // Left
                    {
                        const x = this.lens.x + (r - d / 2);
                        const startAngle = Math.PI - theta;
                        const endAngle = Math.PI + theta;
                        ctx.beginPath();
                        ctx.arc(x, y, r, startAngle, endAngle);
                        ctx.stroke();
                    }
                    // Right
                    {
                        const x = this.lens.x - (r - d / 2);
                        const startAngle = - theta;
                        const endAngle = theta;
                        ctx.beginPath();
                        ctx.arc(x, y, r, startAngle, endAngle);
                        ctx.stroke();
                    }
                }

                //--------------------------------
                // Aperture
                //--------------------------------
                // upper
                {
                    ctx.beginPath();
                    ctx.moveTo(this.lens.x, -this.lensSize);
                    ctx.lineTo(this.lens.x, -this.lensSize * this.aperture);
                    ctx.stroke();
                }
                // lower
                {
                    ctx.beginPath();
                    ctx.moveTo(this.lens.x, this.lensSize);
                    ctx.lineTo(this.lens.x, this.lensSize * this.aperture);
                    ctx.stroke();
                }

                //--------------------------------
                // Copy offscreen render result to main canvas
                //--------------------------------
                mainCtx.transferFromImageBitmap(offscreen.transferToImageBitmap());

                //================================
                // Sensor canvas drawing
                //================================
                sensorCanvasCtx.reset();
                sensorCanvasCtx.fillRect(0, 0, this.sensorCanvas.width, this.sensorCanvas.height); // background
                const sensorCanvasScale = this.sensorCanvas.height / (this.sensor.size * 2);
                sensorCanvasCtx.transform(8192, 0, 0, sensorCanvasScale, this.sensorCanvas.width / 2, this.sensorCanvas.height / 2);
                sensorCanvasCtx.globalCompositeOperation = 'lighten';

                sensorIntersections.forEach((sensorIntersectionsForLight, idx) => {
                    const color = this.lights[idx].color;
                    sensorCanvasCtx.fillStyle = color;
                    sensorIntersectionsForLight.forEach((y) => {
                        sensorCanvasCtx.beginPath();
                        sensorCanvasCtx.arc(0, y, this.rayWidth / 2 / 50, 0, Math.PI * 2);
                        sensorCanvasCtx.fill();
                    });
                });
            }

            // Render only when data changed or window resized
            this.$watch('$data', () => {
                requestAnimationFrame(render);
            }, { deep: true, immediate: true });
            window.addEventListener("resize", render);
        },
    }).mount('#app')
</script>